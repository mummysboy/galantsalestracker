{"ast":null,"code":"/**\n * Parse Alpine TXT sales report files\n * @param txtContent Raw TXT content as string\n * @param reportDate Report date to identify the period (format: YYYY-MM)\n * @returns Parsed Alpine sales data\n */\nexport function parseAlpineTXT(txtContent, reportDate) {\n  const lines = txtContent.split('\\n');\n  const records = [];\n  const supplier = 'ALPINE';\n\n  // Look for period information in the header\n  const headerLine = lines.find(line => line.includes('FROM :') && line.includes('THRU'));\n  let period = reportDate;\n  if (headerLine) {\n    const match = headerLine.match(/(\\d{1,2}\\/\\d{1,2}\\/\\d{2,4})/g);\n    if (match && match.length >= 2) {\n      const [, toDate] = match;\n      const [month, day, year] = toDate.includes('/') ? toDate.split('/') : ['', '', ''];\n      if (month && year) {\n        // Convert to YYYY-MM format\n        const fullYear = year.length === 2 ? `20${year}` : year;\n        period = `${fullYear}-${month.padStart(2, '0')}`;\n      }\n    }\n  }\n\n  // Find customers and their purchases\n  let currentCustomer = '';\n  let currentCustomerId = '';\n  let currentCustomers = [];\n  let currentProducts = [];\n  for (let i = 0; i < lines.length; i++) {\n    const originalLine = lines[i];\n    const line = originalLine.trim();\n\n    // Skip empty lines and headers\n    if (!line || line.startsWith('IT415V') || line.startsWith('SALES RECAP') || line.startsWith('FROM :') || line.startsWith('RUN DATE') || line.startsWith('GALANT GALANT') || line.startsWith('ALPINE') || line.startsWith('DESCRIPTION') || line.startsWith('-----------') || line === 'SALES' || line.includes('MFG ITEM #')) {\n      continue;\n    }\n\n    // Check if this is a customer line (starts with customer number and description)\n    // Updated regex to handle both 4-digit and 5-digit customer numbers\n    const customerMatch = line.match(/^\\s*(\\d{4,5}-\\d{3})\\s+(.+)/);\n    if (customerMatch) {\n      const [, customerId, customerDescription] = customerMatch;\n      currentCustomer = customerDescription.trim();\n      currentCustomerId = customerId.trim();\n      currentCustomers.push(currentCustomer);\n      continue;\n    }\n\n    // Check if this is a product line (indented with spaces at the beginning)\n    // Use a more flexible approach to handle variable spacing\n    if (originalLine.startsWith('    ') && /^\\s+\\d+/.test(originalLine) && currentCustomer) {\n      // Don't trim the line yet - we need to preserve the original spacing for parsing\n      const parts = originalLine.split(/\\s+/);\n\n      // Look for pattern: itemNumber productName size cases pieces netLbs revenue mfgItemNumber\n      // More flexible matching - allow for variations in the number of parts\n      if (parts.length >= 6 && /^\\d+$/.test(parts[0])) {\n        const itemNumber = parts[0];\n        const productName = parts[1];\n        const size = parts[2];\n        const cases = parts[3];\n        const pieces = parts[4];\n        const netLbs = parts[5];\n        // Handle negative revenue values that end with minus sign\n        let revenue = parts[6] || '0';\n        if (revenue.endsWith('-')) {\n          revenue = '-' + revenue.slice(0, -1);\n        }\n        const mfgItemNumber = parts.slice(7).join(' '); // Join remaining parts for mfg item number\n\n        const record = {\n          customerName: currentCustomer,\n          productName: productName.trim(),\n          size: size.trim(),\n          cases: parseInt(cases) || 0,\n          pieces: parseInt(pieces) || 0,\n          netLbs: parseFloat(netLbs) || 0,\n          revenue: parseFloat(revenue) || 0,\n          mfgItemNumber: mfgItemNumber.trim(),\n          customerId: currentCustomerId,\n          productCode: itemNumber.trim(),\n          period\n        };\n        records.push(record);\n        if (!currentProducts.includes(productName.trim())) {\n          currentProducts.push(productName.trim());\n        }\n        continue;\n      }\n    }\n\n    // Check if this is a customer total line (skip it)\n    if (line.includes('CUSTOMER TOTAL :') || line.includes('RUN TOTALS :')) {\n      continue;\n    }\n  }\n\n  // Calculate metadata\n  const totalRevenue = records.reduce((sum, record) => sum + record.revenue, 0);\n  const totalCases = records.reduce((sum, record) => sum + record.cases, 0);\n  const periodRevenue = {};\n  records.forEach(record => {\n    periodRevenue[record.period] = (periodRevenue[record.period] || 0) + record.revenue;\n  });\n  return {\n    records,\n    metadata: {\n      supplier,\n      periods: [period],\n      customers: Array.from(new Set(currentCustomers)),\n      products: Array.from(new Set(currentProducts)),\n      totalRevenue,\n      totalCases,\n      periodRevenue\n    }\n  };\n}\n\n/**\n * Parse multiple Alpine reports and combine them with period progression\n */\nexport function parseMultipleAlpineReports(reports) {\n  const allRecords = [];\n  const allCustomers = new Set();\n  const allProducts = new Set();\n  const allPeriods = new Set();\n  for (const report of reports) {\n    const parsed = parseAlpineTXT(report.content, report.period);\n    allRecords.push(...parsed.records);\n    parsed.metadata.customers.forEach(c => allCustomers.add(c));\n    parsed.metadata.products.forEach(p => allProducts.add(p));\n    allPeriods.add(parsed.metadata.periods[0]);\n  }\n  const totalRevenue = allRecords.reduce((sum, record) => sum + record.revenue, 0);\n  const totalCases = allRecords.reduce((sum, record) => sum + record.cases, 0);\n  const periodRevenue = {};\n  allRecords.forEach(record => {\n    periodRevenue[record.period] = (periodRevenue[record.period] || 0) + record.revenue;\n  });\n  return {\n    records: allRecords.sort((a, b) => {\n      if (a.period !== b.period) return a.period.localeCompare(b.period);\n      if (a.customerName !== b.customerName) return a.customerName.localeCompare(b.customerName);\n      return a.productName.localeCompare(b.productName);\n    }),\n    metadata: {\n      supplier: 'ALPINE',\n      periods: Array.from(allPeriods).sort(),\n      customers: Array.from(allCustomers).sort(),\n      products: Array.from(allProducts).sort(),\n      totalRevenue,\n      totalCases,\n      periodRevenue\n    }\n  };\n}\n\n/**\n * Analyze customer progression across Alpine periods\n */\n\nexport function analyzeCustomerProgress(records, customerName) {\n  const customerRecords = records.filter(r => r.customerName === customerName);\n\n  // Group by period\n  const periodData = {};\n  customerRecords.forEach(record => {\n    if (!periodData[record.period]) {\n      periodData[record.period] = [];\n    }\n    periodData[record.period].push(record);\n  });\n  const periods = Object.entries(periodData).sort(([a], [b]) => a.localeCompare(b)).map(([period, records]) => {\n    const productRevenue = {};\n    const productCases = {};\n    records.forEach(record => {\n      productRevenue[record.productName] = (productRevenue[record.productName] || 0) + record.revenue;\n      productCases[record.productName] = (productCases[record.productName] || 0) + record.cases;\n    });\n    const topProducts = Object.entries(productRevenue).sort(([, a], [, b]) => b - a).slice(0, 5).map(([productName, revenue]) => ({\n      productName,\n      revenue,\n      cases: productCases[productName]\n    }));\n    return {\n      period,\n      totalRevenue: records.reduce((sum, r) => sum + r.revenue, 0),\n      totalCases: records.reduce((sum, r) => sum + r.cases, 0),\n      productCount: Object.keys(productRevenue).length,\n      topProducts\n    };\n  });\n\n  // Analyze trends\n  let revenueTrend = 'stable';\n  let caseTrend = 'stable';\n  let productTrend = 'stable';\n  if (periods.length === 1) {\n    revenueTrend = 'new';\n    caseTrend = 'new';\n    productTrend = 'new';\n  } else if (periods.length >= 2) {\n    const latest = periods[periods.length - 1];\n    const previous = periods[periods.length - 2];\n    const revenueChange = (latest.totalRevenue - previous.totalRevenue) / previous.totalRevenue;\n    const caseChange = (latest.totalCases - previous.totalCases) / previous.totalCases;\n    const productChange = latest.productCount - previous.productCount;\n    revenueTrend = revenueChange > 0.1 ? 'increasing' : revenueChange < -0.1 ? 'decreasing' : 'stable';\n    caseTrend = caseChange > 0.1 ? 'increasing' : caseChange < -0.1 ? 'decreasing' : 'stable';\n    productTrend = productChange > 0 ? 'expanding' : productChange < 0 ? 'contracting' : 'stable';\n  }\n  let status = 'active';\n  if (periods.length === 0) {\n    status = 'lost';\n  } else if (periods.length === 1 && revenueTrend === 'new') {\n    status = 'emerging';\n  } else if (revenueTrend === 'decreasing' || caseTrend === 'decreasing') {\n    status = 'declining';\n  } else if (revenueTrend === 'increasing' || caseTrend === 'increasing') {\n    status = 'active';\n  }\n  return {\n    customerName,\n    periods,\n    trends: {\n      revenueTrend,\n      caseTrend,\n      productTrend,\n      status\n    }\n  };\n}","map":{"version":3,"names":["parseAlpineTXT","txtContent","reportDate","lines","split","records","supplier","headerLine","find","line","includes","period","match","length","toDate","month","day","year","fullYear","padStart","currentCustomer","currentCustomerId","currentCustomers","currentProducts","i","originalLine","trim","startsWith","customerMatch","customerId","customerDescription","push","test","parts","itemNumber","productName","size","cases","pieces","netLbs","revenue","endsWith","slice","mfgItemNumber","join","record","customerName","parseInt","parseFloat","productCode","totalRevenue","reduce","sum","totalCases","periodRevenue","forEach","metadata","periods","customers","Array","from","Set","products","parseMultipleAlpineReports","reports","allRecords","allCustomers","allProducts","allPeriods","report","parsed","content","c","add","p","sort","a","b","localeCompare","analyzeCustomerProgress","customerRecords","filter","r","periodData","Object","entries","map","productRevenue","productCases","topProducts","productCount","keys","revenueTrend","caseTrend","productTrend","latest","previous","revenueChange","caseChange","productChange","status","trends"],"sources":["/Users/isaachirsch/Desktop/GalantCo/SalesTracker/src/utils/alpineParser.ts"],"sourcesContent":["export interface AlpineSalesRecord {\n  customerName: string;\n  productName: string;\n  size?: string;\n  cases: number;\n  pieces: number;\n  netLbs?: number;\n  revenue: number;\n  mfgItemNumber?: string;\n  period: string; // e.g., \"2025-06\", \"2025-07\", \"2025-08\"\n  customerId?: string;\n  productCode?: string;\n}\n\nexport interface ParsedAlpineData {\n  records: AlpineSalesRecord[];\n  metadata: {\n    supplier: string;\n    periods: string[];\n    customers: string[];\n    products: string[];\n    totalRevenue: number;\n    totalCases: number;\n    periodRevenue: Record<string, number>;\n  };\n}\n\n/**\n * Parse Alpine TXT sales report files\n * @param txtContent Raw TXT content as string\n * @param reportDate Report date to identify the period (format: YYYY-MM)\n * @returns Parsed Alpine sales data\n */\nexport function parseAlpineTXT(txtContent: string, reportDate: string): ParsedAlpineData {\n  const lines = txtContent.split('\\n');\n  const records: AlpineSalesRecord[] = [];\n  const supplier = 'ALPINE';\n  \n  \n  // Look for period information in the header\n  const headerLine = lines.find(line => line.includes('FROM :') && line.includes('THRU'));\n  let period = reportDate;\n  if (headerLine) {\n    const match = headerLine.match(/(\\d{1,2}\\/\\d{1,2}\\/\\d{2,4})/g);\n    if (match && match.length >= 2) {\n      const [, toDate] = match;\n      const [month, day, year] = toDate.includes('/') ? toDate.split('/') : ['', '', ''];\n      if (month && year) {\n        // Convert to YYYY-MM format\n        const fullYear = year.length === 2 ? `20${year}` : year;\n        period = `${fullYear}-${month.padStart(2, '0')}`;\n      }\n    }\n  }\n\n  // Find customers and their purchases\n  let currentCustomer = '';\n  let currentCustomerId = '';\n  let currentCustomers: string[] = [];\n  let currentProducts: string[] = [];\n\n  for (let i = 0; i < lines.length; i++) {\n    const originalLine = lines[i];\n    const line = originalLine.trim();\n    \n    // Skip empty lines and headers\n    if (!line || line.startsWith('IT415V') || line.startsWith('SALES RECAP') || \n        line.startsWith('FROM :') || line.startsWith('RUN DATE') || \n        line.startsWith('GALANT GALANT') || line.startsWith('ALPINE') ||\n        line.startsWith('DESCRIPTION') || line.startsWith('-----------') ||\n        line === 'SALES' || line.includes('MFG ITEM #')) {\n      continue;\n    }\n\n\n    // Check if this is a customer line (starts with customer number and description)\n    // Updated regex to handle both 4-digit and 5-digit customer numbers\n    const customerMatch = line.match(/^\\s*(\\d{4,5}-\\d{3})\\s+(.+)/);\n    if (customerMatch) {\n      const [, customerId, customerDescription] = customerMatch;\n      currentCustomer = customerDescription.trim();\n      currentCustomerId = customerId.trim();\n      currentCustomers.push(currentCustomer);\n      continue;\n    }\n\n    // Check if this is a product line (indented with spaces at the beginning)\n    // Use a more flexible approach to handle variable spacing\n    if (originalLine.startsWith('    ') && /^\\s+\\d+/.test(originalLine) && currentCustomer) {\n      // Don't trim the line yet - we need to preserve the original spacing for parsing\n      const parts = originalLine.split(/\\s+/);\n      \n      // Look for pattern: itemNumber productName size cases pieces netLbs revenue mfgItemNumber\n      // More flexible matching - allow for variations in the number of parts\n      if (parts.length >= 6 && /^\\d+$/.test(parts[0])) {\n        const itemNumber = parts[0];\n        const productName = parts[1];\n        const size = parts[2];\n        const cases = parts[3];\n        const pieces = parts[4];\n        const netLbs = parts[5];\n        // Handle negative revenue values that end with minus sign\n        let revenue = parts[6] || '0';\n        if (revenue.endsWith('-')) {\n          revenue = '-' + revenue.slice(0, -1);\n        }\n        const mfgItemNumber = parts.slice(7).join(' '); // Join remaining parts for mfg item number\n        \n        \n        const record: AlpineSalesRecord = {\n          customerName: currentCustomer,\n          productName: productName.trim(),\n          size: size.trim(),\n          cases: parseInt(cases) || 0,\n          pieces: parseInt(pieces) || 0,\n          netLbs: parseFloat(netLbs) || 0,\n          revenue: parseFloat(revenue) || 0,\n          mfgItemNumber: mfgItemNumber.trim(),\n          customerId: currentCustomerId,\n          productCode: itemNumber.trim(),\n          period\n        };\n\n        records.push(record);\n        \n        if (!currentProducts.includes(productName.trim())) {\n          currentProducts.push(productName.trim());\n        }\n        continue;\n      }\n    }\n\n    // Check if this is a customer total line (skip it)\n    if (line.includes('CUSTOMER TOTAL :') || line.includes('RUN TOTALS :')) {\n      continue;\n    }\n  }\n\n  // Calculate metadata\n  const totalRevenue = records.reduce((sum, record) => sum + record.revenue, 0);\n  const totalCases = records.reduce((sum, record) => sum + record.cases, 0);\n  \n  const periodRevenue: Record<string, number> = {};\n  records.forEach(record => {\n    periodRevenue[record.period] = (periodRevenue[record.period] || 0) + record.revenue;\n  });\n\n\n  return {\n    records,\n    metadata: {\n      supplier,\n      periods: [period],\n      customers: Array.from(new Set(currentCustomers)),\n      products: Array.from(new Set(currentProducts)),\n      totalRevenue,\n      totalCases,\n      periodRevenue\n    }\n  };\n}\n\n/**\n * Parse multiple Alpine reports and combine them with period progression\n */\nexport function parseMultipleAlpineReports(\n  reports: Array<{ content: string; period: string }>\n): ParsedAlpineData {\n  const allRecords: AlpineSalesRecord[] = [];\n  const allCustomers = new Set<string>();\n  const allProducts = new Set<string>();\n  const allPeriods = new Set<string>();\n\n  for (const report of reports) {\n    const parsed = parseAlpineTXT(report.content, report.period);\n    allRecords.push(...parsed.records);\n    parsed.metadata.customers.forEach(c => allCustomers.add(c));\n    parsed.metadata.products.forEach(p => allProducts.add(p));\n    allPeriods.add(parsed.metadata.periods[0]);\n  }\n\n  const totalRevenue = allRecords.reduce((sum, record) => sum + record.revenue, 0);\n  const totalCases = allRecords.reduce((sum, record) => sum + record.cases, 0);\n\n  const periodRevenue: Record<string, number> = {};\n  allRecords.forEach(record => {\n    periodRevenue[record.period] = (periodRevenue[record.period] || 0) + record.revenue;\n  });\n\n  return {\n    records: allRecords.sort((a, b) => {\n      if (a.period !== b.period) return a.period.localeCompare(b.period);\n      if (a.customerName !== b.customerName) return a.customerName.localeCompare(b.customerName);\n      return a.productName.localeCompare(b.productName);\n    }),\n    metadata: {\n      supplier: 'ALPINE',\n      periods: Array.from(allPeriods).sort(),\n      customers: Array.from(allCustomers).sort(),\n      products: Array.from(allProducts).sort(),\n      totalRevenue,\n      totalCases,\n      periodRevenue\n    }\n  };\n}\n\n/**\n * Analyze customer progression across Alpine periods\n */\nexport interface CustomerProgressAnalysis {\n  customerName: string;\n  periods: Array<{\n    period: string;\n    totalRevenue: number;\n    totalCases: number;\n    productCount: number;\n    topProducts: Array<{ productName: string; revenue: number; cases: number }>;\n  }>;\n  trends: {\n    revenueTrend: 'increasing' | 'decreasing' | 'stable' | 'new';\n    caseTrend: 'increasing' | 'decreasing' | 'stable' | 'new';\n    productTrend: 'expanding' | 'contracting' | 'stable' | 'new';\n    status: 'active' | 'declining' | 'emerging' | 'lost';\n  };\n}\n\nexport function analyzeCustomerProgress(\n  records: AlpineSalesRecord[], \n  customerName: string\n): CustomerProgressAnalysis {\n  const customerRecords = records.filter(r => r.customerName === customerName);\n  \n  // Group by period\n  const periodData: Record<string, AlpineSalesRecord[]> = {};\n  customerRecords.forEach(record => {\n    if (!periodData[record.period]) {\n      periodData[record.period] = [];\n    }\n    periodData[record.period].push(record);\n  });\n\n  const periods = Object.entries(periodData)\n    .sort(([a], [b]) => a.localeCompare(b))\n    .map(([period, records]) => {\n      const productRevenue: Record<string, number> = {};\n      const productCases: Record<string, number> = {};\n      \n      records.forEach(record => {\n        productRevenue[record.productName] = (productRevenue[record.productName] || 0) + record.revenue;\n        productCases[record.productName] = (productCases[record.productName] || 0) + record.cases;\n      });\n\n      const topProducts = Object.entries(productRevenue)\n        .sort(([,a], [,b]) => b - a)\n        .slice(0, 5)\n        .map(([productName, revenue]) => ({\n          productName,\n          revenue,\n          cases: productCases[productName]\n        }));\n\n      return {\n        period,\n        totalRevenue: records.reduce((sum, r) => sum + r.revenue, 0),\n        totalCases: records.reduce((sum, r) => sum + r.cases, 0),\n        productCount: Object.keys(productRevenue).length,\n        topProducts\n      };\n    });\n\n  // Analyze trends\n  let revenueTrend: 'increasing' | 'decreasing' | 'stable' | 'new' = 'stable';\n  let caseTrend: 'increasing' | 'decreasing' | 'stable' | 'new' = 'stable';\n  let productTrend: 'expanding' | 'contracting' | 'stable' | 'new' = 'stable';\n\n  if (periods.length === 1) {\n    revenueTrend = 'new';\n    caseTrend = 'new';\n    productTrend = 'new';\n  } else if (periods.length >= 2) {\n    const latest = periods[periods.length - 1];\n    const previous = periods[periods.length - 2];\n    \n    const revenueChange = (latest.totalRevenue - previous.totalRevenue) / previous.totalRevenue;\n    const caseChange = (latest.totalCases - previous.totalCases) / previous.totalCases;\n    const productChange = latest.productCount - previous.productCount;\n    \n    revenueTrend = revenueChange > 0.1 ? 'increasing' : (revenueChange < -0.1 ? 'decreasing' : 'stable');\n    caseTrend = caseChange > 0.1 ? 'increasing' : (caseChange < -0.1 ? 'decreasing' : 'stable');\n    productTrend = productChange > 0 ? 'expanding' : (productChange < 0 ? 'contracting' : 'stable');\n  }\n\n  let status: 'active' | 'declining' | 'emerging' | 'lost' = 'active';\n  if (periods.length === 0) {\n    status = 'lost';\n  } else if (periods.length === 1 && revenueTrend === 'new') {\n    status = 'emerging';\n  } else if (revenueTrend === 'decreasing' || caseTrend === 'decreasing') {\n    status = 'declining';\n  } else if (revenueTrend === 'increasing' || caseTrend === 'increasing') {\n    status = 'active';\n  }\n\n  return {\n    customerName,\n    periods,\n    trends: {\n      revenueTrend,\n      caseTrend,\n      productTrend,\n      status\n    }\n  };\n}\n"],"mappings":"AA2BA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,cAAcA,CAACC,UAAkB,EAAEC,UAAkB,EAAoB;EACvF,MAAMC,KAAK,GAAGF,UAAU,CAACG,KAAK,CAAC,IAAI,CAAC;EACpC,MAAMC,OAA4B,GAAG,EAAE;EACvC,MAAMC,QAAQ,GAAG,QAAQ;;EAGzB;EACA,MAAMC,UAAU,GAAGJ,KAAK,CAACK,IAAI,CAACC,IAAI,IAAIA,IAAI,CAACC,QAAQ,CAAC,QAAQ,CAAC,IAAID,IAAI,CAACC,QAAQ,CAAC,MAAM,CAAC,CAAC;EACvF,IAAIC,MAAM,GAAGT,UAAU;EACvB,IAAIK,UAAU,EAAE;IACd,MAAMK,KAAK,GAAGL,UAAU,CAACK,KAAK,CAAC,8BAA8B,CAAC;IAC9D,IAAIA,KAAK,IAAIA,KAAK,CAACC,MAAM,IAAI,CAAC,EAAE;MAC9B,MAAM,GAAGC,MAAM,CAAC,GAAGF,KAAK;MACxB,MAAM,CAACG,KAAK,EAAEC,GAAG,EAAEC,IAAI,CAAC,GAAGH,MAAM,CAACJ,QAAQ,CAAC,GAAG,CAAC,GAAGI,MAAM,CAACV,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC;MAClF,IAAIW,KAAK,IAAIE,IAAI,EAAE;QACjB;QACA,MAAMC,QAAQ,GAAGD,IAAI,CAACJ,MAAM,KAAK,CAAC,GAAG,KAAKI,IAAI,EAAE,GAAGA,IAAI;QACvDN,MAAM,GAAG,GAAGO,QAAQ,IAAIH,KAAK,CAACI,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,EAAE;MAClD;IACF;EACF;;EAEA;EACA,IAAIC,eAAe,GAAG,EAAE;EACxB,IAAIC,iBAAiB,GAAG,EAAE;EAC1B,IAAIC,gBAA0B,GAAG,EAAE;EACnC,IAAIC,eAAyB,GAAG,EAAE;EAElC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGrB,KAAK,CAACU,MAAM,EAAEW,CAAC,EAAE,EAAE;IACrC,MAAMC,YAAY,GAAGtB,KAAK,CAACqB,CAAC,CAAC;IAC7B,MAAMf,IAAI,GAAGgB,YAAY,CAACC,IAAI,CAAC,CAAC;;IAEhC;IACA,IAAI,CAACjB,IAAI,IAAIA,IAAI,CAACkB,UAAU,CAAC,QAAQ,CAAC,IAAIlB,IAAI,CAACkB,UAAU,CAAC,aAAa,CAAC,IACpElB,IAAI,CAACkB,UAAU,CAAC,QAAQ,CAAC,IAAIlB,IAAI,CAACkB,UAAU,CAAC,UAAU,CAAC,IACxDlB,IAAI,CAACkB,UAAU,CAAC,eAAe,CAAC,IAAIlB,IAAI,CAACkB,UAAU,CAAC,QAAQ,CAAC,IAC7DlB,IAAI,CAACkB,UAAU,CAAC,aAAa,CAAC,IAAIlB,IAAI,CAACkB,UAAU,CAAC,aAAa,CAAC,IAChElB,IAAI,KAAK,OAAO,IAAIA,IAAI,CAACC,QAAQ,CAAC,YAAY,CAAC,EAAE;MACnD;IACF;;IAGA;IACA;IACA,MAAMkB,aAAa,GAAGnB,IAAI,CAACG,KAAK,CAAC,4BAA4B,CAAC;IAC9D,IAAIgB,aAAa,EAAE;MACjB,MAAM,GAAGC,UAAU,EAAEC,mBAAmB,CAAC,GAAGF,aAAa;MACzDR,eAAe,GAAGU,mBAAmB,CAACJ,IAAI,CAAC,CAAC;MAC5CL,iBAAiB,GAAGQ,UAAU,CAACH,IAAI,CAAC,CAAC;MACrCJ,gBAAgB,CAACS,IAAI,CAACX,eAAe,CAAC;MACtC;IACF;;IAEA;IACA;IACA,IAAIK,YAAY,CAACE,UAAU,CAAC,MAAM,CAAC,IAAI,SAAS,CAACK,IAAI,CAACP,YAAY,CAAC,IAAIL,eAAe,EAAE;MACtF;MACA,MAAMa,KAAK,GAAGR,YAAY,CAACrB,KAAK,CAAC,KAAK,CAAC;;MAEvC;MACA;MACA,IAAI6B,KAAK,CAACpB,MAAM,IAAI,CAAC,IAAI,OAAO,CAACmB,IAAI,CAACC,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE;QAC/C,MAAMC,UAAU,GAAGD,KAAK,CAAC,CAAC,CAAC;QAC3B,MAAME,WAAW,GAAGF,KAAK,CAAC,CAAC,CAAC;QAC5B,MAAMG,IAAI,GAAGH,KAAK,CAAC,CAAC,CAAC;QACrB,MAAMI,KAAK,GAAGJ,KAAK,CAAC,CAAC,CAAC;QACtB,MAAMK,MAAM,GAAGL,KAAK,CAAC,CAAC,CAAC;QACvB,MAAMM,MAAM,GAAGN,KAAK,CAAC,CAAC,CAAC;QACvB;QACA,IAAIO,OAAO,GAAGP,KAAK,CAAC,CAAC,CAAC,IAAI,GAAG;QAC7B,IAAIO,OAAO,CAACC,QAAQ,CAAC,GAAG,CAAC,EAAE;UACzBD,OAAO,GAAG,GAAG,GAAGA,OAAO,CAACE,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QACtC;QACA,MAAMC,aAAa,GAAGV,KAAK,CAACS,KAAK,CAAC,CAAC,CAAC,CAACE,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;;QAGhD,MAAMC,MAAyB,GAAG;UAChCC,YAAY,EAAE1B,eAAe;UAC7Be,WAAW,EAAEA,WAAW,CAACT,IAAI,CAAC,CAAC;UAC/BU,IAAI,EAAEA,IAAI,CAACV,IAAI,CAAC,CAAC;UACjBW,KAAK,EAAEU,QAAQ,CAACV,KAAK,CAAC,IAAI,CAAC;UAC3BC,MAAM,EAAES,QAAQ,CAACT,MAAM,CAAC,IAAI,CAAC;UAC7BC,MAAM,EAAES,UAAU,CAACT,MAAM,CAAC,IAAI,CAAC;UAC/BC,OAAO,EAAEQ,UAAU,CAACR,OAAO,CAAC,IAAI,CAAC;UACjCG,aAAa,EAAEA,aAAa,CAACjB,IAAI,CAAC,CAAC;UACnCG,UAAU,EAAER,iBAAiB;UAC7B4B,WAAW,EAAEf,UAAU,CAACR,IAAI,CAAC,CAAC;UAC9Bf;QACF,CAAC;QAEDN,OAAO,CAAC0B,IAAI,CAACc,MAAM,CAAC;QAEpB,IAAI,CAACtB,eAAe,CAACb,QAAQ,CAACyB,WAAW,CAACT,IAAI,CAAC,CAAC,CAAC,EAAE;UACjDH,eAAe,CAACQ,IAAI,CAACI,WAAW,CAACT,IAAI,CAAC,CAAC,CAAC;QAC1C;QACA;MACF;IACF;;IAEA;IACA,IAAIjB,IAAI,CAACC,QAAQ,CAAC,kBAAkB,CAAC,IAAID,IAAI,CAACC,QAAQ,CAAC,cAAc,CAAC,EAAE;MACtE;IACF;EACF;;EAEA;EACA,MAAMwC,YAAY,GAAG7C,OAAO,CAAC8C,MAAM,CAAC,CAACC,GAAG,EAAEP,MAAM,KAAKO,GAAG,GAAGP,MAAM,CAACL,OAAO,EAAE,CAAC,CAAC;EAC7E,MAAMa,UAAU,GAAGhD,OAAO,CAAC8C,MAAM,CAAC,CAACC,GAAG,EAAEP,MAAM,KAAKO,GAAG,GAAGP,MAAM,CAACR,KAAK,EAAE,CAAC,CAAC;EAEzE,MAAMiB,aAAqC,GAAG,CAAC,CAAC;EAChDjD,OAAO,CAACkD,OAAO,CAACV,MAAM,IAAI;IACxBS,aAAa,CAACT,MAAM,CAAClC,MAAM,CAAC,GAAG,CAAC2C,aAAa,CAACT,MAAM,CAAClC,MAAM,CAAC,IAAI,CAAC,IAAIkC,MAAM,CAACL,OAAO;EACrF,CAAC,CAAC;EAGF,OAAO;IACLnC,OAAO;IACPmD,QAAQ,EAAE;MACRlD,QAAQ;MACRmD,OAAO,EAAE,CAAC9C,MAAM,CAAC;MACjB+C,SAAS,EAAEC,KAAK,CAACC,IAAI,CAAC,IAAIC,GAAG,CAACvC,gBAAgB,CAAC,CAAC;MAChDwC,QAAQ,EAAEH,KAAK,CAACC,IAAI,CAAC,IAAIC,GAAG,CAACtC,eAAe,CAAC,CAAC;MAC9C2B,YAAY;MACZG,UAAU;MACVC;IACF;EACF,CAAC;AACH;;AAEA;AACA;AACA;AACA,OAAO,SAASS,0BAA0BA,CACxCC,OAAmD,EACjC;EAClB,MAAMC,UAA+B,GAAG,EAAE;EAC1C,MAAMC,YAAY,GAAG,IAAIL,GAAG,CAAS,CAAC;EACtC,MAAMM,WAAW,GAAG,IAAIN,GAAG,CAAS,CAAC;EACrC,MAAMO,UAAU,GAAG,IAAIP,GAAG,CAAS,CAAC;EAEpC,KAAK,MAAMQ,MAAM,IAAIL,OAAO,EAAE;IAC5B,MAAMM,MAAM,GAAGtE,cAAc,CAACqE,MAAM,CAACE,OAAO,EAAEF,MAAM,CAAC1D,MAAM,CAAC;IAC5DsD,UAAU,CAAClC,IAAI,CAAC,GAAGuC,MAAM,CAACjE,OAAO,CAAC;IAClCiE,MAAM,CAACd,QAAQ,CAACE,SAAS,CAACH,OAAO,CAACiB,CAAC,IAAIN,YAAY,CAACO,GAAG,CAACD,CAAC,CAAC,CAAC;IAC3DF,MAAM,CAACd,QAAQ,CAACM,QAAQ,CAACP,OAAO,CAACmB,CAAC,IAAIP,WAAW,CAACM,GAAG,CAACC,CAAC,CAAC,CAAC;IACzDN,UAAU,CAACK,GAAG,CAACH,MAAM,CAACd,QAAQ,CAACC,OAAO,CAAC,CAAC,CAAC,CAAC;EAC5C;EAEA,MAAMP,YAAY,GAAGe,UAAU,CAACd,MAAM,CAAC,CAACC,GAAG,EAAEP,MAAM,KAAKO,GAAG,GAAGP,MAAM,CAACL,OAAO,EAAE,CAAC,CAAC;EAChF,MAAMa,UAAU,GAAGY,UAAU,CAACd,MAAM,CAAC,CAACC,GAAG,EAAEP,MAAM,KAAKO,GAAG,GAAGP,MAAM,CAACR,KAAK,EAAE,CAAC,CAAC;EAE5E,MAAMiB,aAAqC,GAAG,CAAC,CAAC;EAChDW,UAAU,CAACV,OAAO,CAACV,MAAM,IAAI;IAC3BS,aAAa,CAACT,MAAM,CAAClC,MAAM,CAAC,GAAG,CAAC2C,aAAa,CAACT,MAAM,CAAClC,MAAM,CAAC,IAAI,CAAC,IAAIkC,MAAM,CAACL,OAAO;EACrF,CAAC,CAAC;EAEF,OAAO;IACLnC,OAAO,EAAE4D,UAAU,CAACU,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAK;MACjC,IAAID,CAAC,CAACjE,MAAM,KAAKkE,CAAC,CAAClE,MAAM,EAAE,OAAOiE,CAAC,CAACjE,MAAM,CAACmE,aAAa,CAACD,CAAC,CAAClE,MAAM,CAAC;MAClE,IAAIiE,CAAC,CAAC9B,YAAY,KAAK+B,CAAC,CAAC/B,YAAY,EAAE,OAAO8B,CAAC,CAAC9B,YAAY,CAACgC,aAAa,CAACD,CAAC,CAAC/B,YAAY,CAAC;MAC1F,OAAO8B,CAAC,CAACzC,WAAW,CAAC2C,aAAa,CAACD,CAAC,CAAC1C,WAAW,CAAC;IACnD,CAAC,CAAC;IACFqB,QAAQ,EAAE;MACRlD,QAAQ,EAAE,QAAQ;MAClBmD,OAAO,EAAEE,KAAK,CAACC,IAAI,CAACQ,UAAU,CAAC,CAACO,IAAI,CAAC,CAAC;MACtCjB,SAAS,EAAEC,KAAK,CAACC,IAAI,CAACM,YAAY,CAAC,CAACS,IAAI,CAAC,CAAC;MAC1Cb,QAAQ,EAAEH,KAAK,CAACC,IAAI,CAACO,WAAW,CAAC,CAACQ,IAAI,CAAC,CAAC;MACxCzB,YAAY;MACZG,UAAU;MACVC;IACF;EACF,CAAC;AACH;;AAEA;AACA;AACA;;AAkBA,OAAO,SAASyB,uBAAuBA,CACrC1E,OAA4B,EAC5ByC,YAAoB,EACM;EAC1B,MAAMkC,eAAe,GAAG3E,OAAO,CAAC4E,MAAM,CAACC,CAAC,IAAIA,CAAC,CAACpC,YAAY,KAAKA,YAAY,CAAC;;EAE5E;EACA,MAAMqC,UAA+C,GAAG,CAAC,CAAC;EAC1DH,eAAe,CAACzB,OAAO,CAACV,MAAM,IAAI;IAChC,IAAI,CAACsC,UAAU,CAACtC,MAAM,CAAClC,MAAM,CAAC,EAAE;MAC9BwE,UAAU,CAACtC,MAAM,CAAClC,MAAM,CAAC,GAAG,EAAE;IAChC;IACAwE,UAAU,CAACtC,MAAM,CAAClC,MAAM,CAAC,CAACoB,IAAI,CAACc,MAAM,CAAC;EACxC,CAAC,CAAC;EAEF,MAAMY,OAAO,GAAG2B,MAAM,CAACC,OAAO,CAACF,UAAU,CAAC,CACvCR,IAAI,CAAC,CAAC,CAACC,CAAC,CAAC,EAAE,CAACC,CAAC,CAAC,KAAKD,CAAC,CAACE,aAAa,CAACD,CAAC,CAAC,CAAC,CACtCS,GAAG,CAAC,CAAC,CAAC3E,MAAM,EAAEN,OAAO,CAAC,KAAK;IAC1B,MAAMkF,cAAsC,GAAG,CAAC,CAAC;IACjD,MAAMC,YAAoC,GAAG,CAAC,CAAC;IAE/CnF,OAAO,CAACkD,OAAO,CAACV,MAAM,IAAI;MACxB0C,cAAc,CAAC1C,MAAM,CAACV,WAAW,CAAC,GAAG,CAACoD,cAAc,CAAC1C,MAAM,CAACV,WAAW,CAAC,IAAI,CAAC,IAAIU,MAAM,CAACL,OAAO;MAC/FgD,YAAY,CAAC3C,MAAM,CAACV,WAAW,CAAC,GAAG,CAACqD,YAAY,CAAC3C,MAAM,CAACV,WAAW,CAAC,IAAI,CAAC,IAAIU,MAAM,CAACR,KAAK;IAC3F,CAAC,CAAC;IAEF,MAAMoD,WAAW,GAAGL,MAAM,CAACC,OAAO,CAACE,cAAc,CAAC,CAC/CZ,IAAI,CAAC,CAAC,GAAEC,CAAC,CAAC,EAAE,GAAEC,CAAC,CAAC,KAAKA,CAAC,GAAGD,CAAC,CAAC,CAC3BlC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CACX4C,GAAG,CAAC,CAAC,CAACnD,WAAW,EAAEK,OAAO,CAAC,MAAM;MAChCL,WAAW;MACXK,OAAO;MACPH,KAAK,EAAEmD,YAAY,CAACrD,WAAW;IACjC,CAAC,CAAC,CAAC;IAEL,OAAO;MACLxB,MAAM;MACNuC,YAAY,EAAE7C,OAAO,CAAC8C,MAAM,CAAC,CAACC,GAAG,EAAE8B,CAAC,KAAK9B,GAAG,GAAG8B,CAAC,CAAC1C,OAAO,EAAE,CAAC,CAAC;MAC5Da,UAAU,EAAEhD,OAAO,CAAC8C,MAAM,CAAC,CAACC,GAAG,EAAE8B,CAAC,KAAK9B,GAAG,GAAG8B,CAAC,CAAC7C,KAAK,EAAE,CAAC,CAAC;MACxDqD,YAAY,EAAEN,MAAM,CAACO,IAAI,CAACJ,cAAc,CAAC,CAAC1E,MAAM;MAChD4E;IACF,CAAC;EACH,CAAC,CAAC;;EAEJ;EACA,IAAIG,YAA4D,GAAG,QAAQ;EAC3E,IAAIC,SAAyD,GAAG,QAAQ;EACxE,IAAIC,YAA4D,GAAG,QAAQ;EAE3E,IAAIrC,OAAO,CAAC5C,MAAM,KAAK,CAAC,EAAE;IACxB+E,YAAY,GAAG,KAAK;IACpBC,SAAS,GAAG,KAAK;IACjBC,YAAY,GAAG,KAAK;EACtB,CAAC,MAAM,IAAIrC,OAAO,CAAC5C,MAAM,IAAI,CAAC,EAAE;IAC9B,MAAMkF,MAAM,GAAGtC,OAAO,CAACA,OAAO,CAAC5C,MAAM,GAAG,CAAC,CAAC;IAC1C,MAAMmF,QAAQ,GAAGvC,OAAO,CAACA,OAAO,CAAC5C,MAAM,GAAG,CAAC,CAAC;IAE5C,MAAMoF,aAAa,GAAG,CAACF,MAAM,CAAC7C,YAAY,GAAG8C,QAAQ,CAAC9C,YAAY,IAAI8C,QAAQ,CAAC9C,YAAY;IAC3F,MAAMgD,UAAU,GAAG,CAACH,MAAM,CAAC1C,UAAU,GAAG2C,QAAQ,CAAC3C,UAAU,IAAI2C,QAAQ,CAAC3C,UAAU;IAClF,MAAM8C,aAAa,GAAGJ,MAAM,CAACL,YAAY,GAAGM,QAAQ,CAACN,YAAY;IAEjEE,YAAY,GAAGK,aAAa,GAAG,GAAG,GAAG,YAAY,GAAIA,aAAa,GAAG,CAAC,GAAG,GAAG,YAAY,GAAG,QAAS;IACpGJ,SAAS,GAAGK,UAAU,GAAG,GAAG,GAAG,YAAY,GAAIA,UAAU,GAAG,CAAC,GAAG,GAAG,YAAY,GAAG,QAAS;IAC3FJ,YAAY,GAAGK,aAAa,GAAG,CAAC,GAAG,WAAW,GAAIA,aAAa,GAAG,CAAC,GAAG,aAAa,GAAG,QAAS;EACjG;EAEA,IAAIC,MAAoD,GAAG,QAAQ;EACnE,IAAI3C,OAAO,CAAC5C,MAAM,KAAK,CAAC,EAAE;IACxBuF,MAAM,GAAG,MAAM;EACjB,CAAC,MAAM,IAAI3C,OAAO,CAAC5C,MAAM,KAAK,CAAC,IAAI+E,YAAY,KAAK,KAAK,EAAE;IACzDQ,MAAM,GAAG,UAAU;EACrB,CAAC,MAAM,IAAIR,YAAY,KAAK,YAAY,IAAIC,SAAS,KAAK,YAAY,EAAE;IACtEO,MAAM,GAAG,WAAW;EACtB,CAAC,MAAM,IAAIR,YAAY,KAAK,YAAY,IAAIC,SAAS,KAAK,YAAY,EAAE;IACtEO,MAAM,GAAG,QAAQ;EACnB;EAEA,OAAO;IACLtD,YAAY;IACZW,OAAO;IACP4C,MAAM,EAAE;MACNT,YAAY;MACZC,SAAS;MACTC,YAAY;MACZM;IACF;EACF,CAAC;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}