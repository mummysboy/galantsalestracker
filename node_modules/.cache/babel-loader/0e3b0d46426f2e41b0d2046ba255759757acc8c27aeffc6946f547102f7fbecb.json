{"ast":null,"code":"/**\n * Parse Alpine TXT sales report files\n * @param txtContent Raw TXT content as string\n * @param reportDate Report date to identify the period (format: YYYY-MM)\n * @returns Parsed Alpine sales data\n */\nexport function parseAlpineTXT(txtContent, reportDate) {\n  const lines = txtContent.split('\\n');\n  const records = [];\n  const supplier = 'ALPINE';\n\n  // Look for period information in the header\n  const headerLine = lines.find(line => line.includes('FROM :') && line.includes('THRU'));\n  let period = reportDate;\n  if (headerLine) {\n    const match = headerLine.match(/(\\d{1,2}\\/\\d{1,2}\\/\\d{2,4})/g);\n    if (match && match.length >= 2) {\n      const [, toDate] = match;\n      const [month, day, year] = toDate.includes('/') ? toDate.split('/') : ['', '', ''];\n      if (month && year) {\n        // Convert to YYYY-MM format\n        const fullYear = year.length === 2 ? `20${year}` : year;\n        period = `${fullYear}-${month.padStart(2, '0')}`;\n      }\n    }\n  }\n\n  // Find customers and their purchases\n  let currentCustomer = '';\n  let currentCustomerId = '';\n  let currentCustomers = [];\n  let currentProducts = [];\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n\n    // Skip empty lines and headers\n    if (!line || line.startsWith('IT415V') || line.startsWith('SALES RECAP') || line.startsWith('FROM :') || line.startsWith('RUN DATE') || line.startsWith('GALANT GALANT') || line.startsWith('ALPINE') || line.startsWith('DESCRIPTION') || line.startsWith('-----------') || line === 'SALES' || line.includes('MFG ITEM #')) {\n      continue;\n    }\n\n    // Check if this is a customer line (starts with customer number and description)\n    const customerMatch = line.match(/^(\\d{6}-\\d{3})\\s+(.+)$/);\n    if (customerMatch) {\n      const [, customerId, customerDescription] = customerMatch;\n      currentCustomer = customerDescription.trim();\n      currentCustomerId = customerId.trim();\n      currentCustomers.push(currentCustomer);\n      continue;\n    }\n\n    // Check if this is a product line (indented with spaces at the beginning)\n    // Pattern: spaces + itemNumber + spaces + productName + spaces + size + spaces + cases + spaces + pieces + spaces + netLbs + spaces + revenue + spaces + mfgItemNumber\n    // Example: \"    184016  GAL SAMPLE KIT            12 CT            1                  3.00           .01                      GAL SAMPLE\"\n    const productMatch = line.match(/^\\s+(\\d+)\\s+(.+?)\\s+([0-9A-Z\\s\\/-]+?)\\s+(\\d+)\\s+(\\d+)\\s+([0-9.-]+)\\s+([0-9.-]+)\\s+([A-Z0-9\\s]+)$/);\n    if (productMatch && currentCustomer) {\n      const [, itemNumber, productName, size, cases, pieces, netLbs, revenue, mfgItemNumber] = productMatch;\n      const record = {\n        customerName: currentCustomer,\n        productName: productName.trim(),\n        size: size.trim(),\n        cases: parseInt(cases) || 0,\n        pieces: parseInt(pieces) || 0,\n        netLbs: parseFloat(netLbs) || 0,\n        revenue: parseFloat(revenue) || 0,\n        mfgItemNumber: mfgItemNumber.trim(),\n        customerId: currentCustomerId,\n        productCode: itemNumber.trim(),\n        period\n      };\n      records.push(record);\n      if (!currentProducts.includes(productName.trim())) {\n        currentProducts.push(productName.trim());\n      }\n      continue;\n    }\n\n    // Check for alternative product line format (some items might have different spacing)\n    // Pattern without Net LBS: spaces + itemNumber + spaces + productName + spaces + size + spaces + cases + spaces + pieces + spaces + revenue + spaces + mfgItemNumber\n    const altProductMatch = line.match(/^\\s+(\\d+)\\s+(.+?)\\s+([A-Z0-9\\s\\/.-]+?)\\s+(\\d+)\\s+(\\d+)\\s+([0-9.-]+)\\s+([A-Z0-9\\s]+)$/);\n    if (altProductMatch && currentCustomer && !productMatch) {\n      const [, itemNumber, productName, size, cases, pieces, revenue, mfgItemNumber] = altProductMatch;\n      const record = {\n        customerName: currentCustomer,\n        productName: productName.trim(),\n        size: size.trim(),\n        cases: parseInt(cases) || 0,\n        pieces: parseInt(pieces) || 0,\n        netLbs: 0,\n        // No Net LBS data in this format\n        revenue: parseFloat(revenue) || 0,\n        mfgItemNumber: mfgItemNumber.trim(),\n        customerId: currentCustomerId,\n        productCode: itemNumber.trim(),\n        period\n      };\n      records.push(record);\n      if (!currentProducts.includes(productName.trim())) {\n        currentProducts.push(productName.trim());\n      }\n      continue;\n    }\n\n    // Check if this is a customer total line (skip it)\n    if (line.includes('CUSTOMER TOTAL :') || line.includes('RUN TOTALS :')) {\n      continue;\n    }\n  }\n\n  // Calculate metadata\n  const totalRevenue = records.reduce((sum, record) => sum + record.revenue, 0);\n  const totalCases = records.reduce((sum, record) => sum + record.cases, 0);\n  const periodRevenue = {};\n  records.forEach(record => {\n    periodRevenue[record.period] = (periodRevenue[record.period] || 0) + record.revenue;\n  });\n  return {\n    records,\n    metadata: {\n      supplier,\n      periods: [period],\n      customers: Array.from(new Set(currentCustomers)),\n      products: Array.from(new Set(currentProducts)),\n      totalRevenue,\n      totalCases,\n      periodRevenue\n    }\n  };\n}\n\n/**\n * Parse multiple Alpine reports and combine them with period progression\n */\nexport function parseMultipleAlpineReports(reports) {\n  const allRecords = [];\n  const allCustomers = new Set();\n  const allProducts = new Set();\n  const allPeriods = new Set();\n  for (const report of reports) {\n    const parsed = parseAlpineTXT(report.content, report.period);\n    allRecords.push(...parsed.records);\n    parsed.metadata.customers.forEach(c => allCustomers.add(c));\n    parsed.metadata.products.forEach(p => allProducts.add(p));\n    allPeriods.add(parsed.metadata.periods[0]);\n  }\n  const totalRevenue = allRecords.reduce((sum, record) => sum + record.revenue, 0);\n  const totalCases = allRecords.reduce((sum, record) => sum + record.cases, 0);\n  const periodRevenue = {};\n  allRecords.forEach(record => {\n    periodRevenue[record.period] = (periodRevenue[record.period] || 0) + record.revenue;\n  });\n  return {\n    records: allRecords.sort((a, b) => {\n      if (a.period !== b.period) return a.period.localeCompare(b.period);\n      if (a.customerName !== b.customerName) return a.customerName.localeCompare(b.customerName);\n      return a.productName.localeCompare(b.productName);\n    }),\n    metadata: {\n      supplier: 'ALPINE',\n      periods: Array.from(allPeriods).sort(),\n      customers: Array.from(allCustomers).sort(),\n      products: Array.from(allProducts).sort(),\n      totalRevenue,\n      totalCases,\n      periodRevenue\n    }\n  };\n}\n\n/**\n * Analyze customer progression across Alpine periods\n */\n\nexport function analyzeCustomerProgress(records, customerName) {\n  const customerRecords = records.filter(r => r.customerName === customerName);\n\n  // Group by period\n  const periodData = {};\n  customerRecords.forEach(record => {\n    if (!periodData[record.period]) {\n      periodData[record.period] = [];\n    }\n    periodData[record.period].push(record);\n  });\n  const periods = Object.entries(periodData).sort(([a], [b]) => a.localeCompare(b)).map(([period, records]) => {\n    const productRevenue = {};\n    const productCases = {};\n    records.forEach(record => {\n      productRevenue[record.productName] = (productRevenue[record.productName] || 0) + record.revenue;\n      productCases[record.productName] = (productCases[record.productName] || 0) + record.cases;\n    });\n    const topProducts = Object.entries(productRevenue).sort(([, a], [, b]) => b - a).slice(0, 5).map(([productName, revenue]) => ({\n      productName,\n      revenue,\n      cases: productCases[productName]\n    }));\n    return {\n      period,\n      totalRevenue: records.reduce((sum, r) => sum + r.revenue, 0),\n      totalCases: records.reduce((sum, r) => sum + r.cases, 0),\n      productCount: Object.keys(productRevenue).length,\n      topProducts\n    };\n  });\n\n  // Analyze trends\n  let revenueTrend = 'stable';\n  let caseTrend = 'stable';\n  let productTrend = 'stable';\n  if (periods.length === 1) {\n    revenueTrend = 'new';\n    caseTrend = 'new';\n    productTrend = 'new';\n  } else if (periods.length >= 2) {\n    const latest = periods[periods.length - 1];\n    const previous = periods[periods.length - 2];\n    const revenueChange = (latest.totalRevenue - previous.totalRevenue) / previous.totalRevenue;\n    const caseChange = (latest.totalCases - previous.totalCases) / previous.totalCases;\n    const productChange = latest.productCount - previous.productCount;\n    revenueTrend = revenueChange > 0.1 ? 'increasing' : revenueChange < -0.1 ? 'decreasing' : 'stable';\n    caseTrend = caseChange > 0.1 ? 'increasing' : caseChange < -0.1 ? 'decreasing' : 'stable';\n    productTrend = productChange > 0 ? 'expanding' : productChange < 0 ? 'contracting' : 'stable';\n  }\n  let status = 'active';\n  if (periods.length === 0) {\n    status = 'lost';\n  } else if (periods.length === 1 && revenueTrend === 'new') {\n    status = 'emerging';\n  } else if (revenueTrend === 'decreasing' || caseTrend === 'decreasing') {\n    status = 'declining';\n  } else if (revenueTrend === 'increasing' || caseTrend === 'increasing') {\n    status = 'active';\n  }\n  return {\n    customerName,\n    periods,\n    trends: {\n      revenueTrend,\n      caseTrend,\n      productTrend,\n      status\n    }\n  };\n}","map":{"version":3,"names":["parseAlpineTXT","txtContent","reportDate","lines","split","records","supplier","headerLine","find","line","includes","period","match","length","toDate","month","day","year","fullYear","padStart","currentCustomer","currentCustomerId","currentCustomers","currentProducts","i","trim","startsWith","customerMatch","customerId","customerDescription","push","productMatch","itemNumber","productName","size","cases","pieces","netLbs","revenue","mfgItemNumber","record","customerName","parseInt","parseFloat","productCode","altProductMatch","totalRevenue","reduce","sum","totalCases","periodRevenue","forEach","metadata","periods","customers","Array","from","Set","products","parseMultipleAlpineReports","reports","allRecords","allCustomers","allProducts","allPeriods","report","parsed","content","c","add","p","sort","a","b","localeCompare","analyzeCustomerProgress","customerRecords","filter","r","periodData","Object","entries","map","productRevenue","productCases","topProducts","slice","productCount","keys","revenueTrend","caseTrend","productTrend","latest","previous","revenueChange","caseChange","productChange","status","trends"],"sources":["/Users/isaachirsch/Desktop/GalantCo/SalesTracker/src/utils/alpineParser.ts"],"sourcesContent":["export interface AlpineSalesRecord {\n  customerName: string;\n  productName: string;\n  size?: string;\n  cases: number;\n  pieces: number;\n  netLbs?: number;\n  revenue: number;\n  mfgItemNumber?: string;\n  period: string; // e.g., \"2025-06\", \"2025-07\", \"2025-08\"\n  customerId?: string;\n  productCode?: string;\n}\n\nexport interface ParsedAlpineData {\n  records: AlpineSalesRecord[];\n  metadata: {\n    supplier: string;\n    periods: string[];\n    customers: string[];\n    products: string[];\n    totalRevenue: number;\n    totalCases: number;\n    periodRevenue: Record<string, number>;\n  };\n}\n\n/**\n * Parse Alpine TXT sales report files\n * @param txtContent Raw TXT content as string\n * @param reportDate Report date to identify the period (format: YYYY-MM)\n * @returns Parsed Alpine sales data\n */\nexport function parseAlpineTXT(txtContent: string, reportDate: string): ParsedAlpineData {\n  const lines = txtContent.split('\\n');\n  const records: AlpineSalesRecord[] = [];\n  const supplier = 'ALPINE';\n  \n  // Look for period information in the header\n  const headerLine = lines.find(line => line.includes('FROM :') && line.includes('THRU'));\n  let period = reportDate;\n  if (headerLine) {\n    const match = headerLine.match(/(\\d{1,2}\\/\\d{1,2}\\/\\d{2,4})/g);\n    if (match && match.length >= 2) {\n      const [, toDate] = match;\n      const [month, day, year] = toDate.includes('/') ? toDate.split('/') : ['', '', ''];\n      if (month && year) {\n        // Convert to YYYY-MM format\n        const fullYear = year.length === 2 ? `20${year}` : year;\n        period = `${fullYear}-${month.padStart(2, '0')}`;\n      }\n    }\n  }\n\n  // Find customers and their purchases\n  let currentCustomer = '';\n  let currentCustomerId = '';\n  let currentCustomers: string[] = [];\n  let currentProducts: string[] = [];\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n    \n    // Skip empty lines and headers\n    if (!line || line.startsWith('IT415V') || line.startsWith('SALES RECAP') || \n        line.startsWith('FROM :') || line.startsWith('RUN DATE') || \n        line.startsWith('GALANT GALANT') || line.startsWith('ALPINE') ||\n        line.startsWith('DESCRIPTION') || line.startsWith('-----------') ||\n        line === 'SALES' || line.includes('MFG ITEM #')) {\n      continue;\n    }\n\n    // Check if this is a customer line (starts with customer number and description)\n    const customerMatch = line.match(/^(\\d{6}-\\d{3})\\s+(.+)$/);\n    if (customerMatch) {\n      const [, customerId, customerDescription] = customerMatch;\n      currentCustomer = customerDescription.trim();\n      currentCustomerId = customerId.trim();\n      currentCustomers.push(currentCustomer);\n      continue;\n    }\n\n    // Check if this is a product line (indented with spaces at the beginning)\n    // Pattern: spaces + itemNumber + spaces + productName + spaces + size + spaces + cases + spaces + pieces + spaces + netLbs + spaces + revenue + spaces + mfgItemNumber\n    // Example: \"    184016  GAL SAMPLE KIT            12 CT            1                  3.00           .01                      GAL SAMPLE\"\n    const productMatch = line.match(/^\\s+(\\d+)\\s+(.+?)\\s+([0-9A-Z\\s\\/-]+?)\\s+(\\d+)\\s+(\\d+)\\s+([0-9.-]+)\\s+([0-9.-]+)\\s+([A-Z0-9\\s]+)$/);\n    if (productMatch && currentCustomer) {\n      const [, itemNumber, productName, size, cases, pieces, netLbs, revenue, mfgItemNumber] = productMatch;\n      \n      const record: AlpineSalesRecord = {\n        customerName: currentCustomer,\n        productName: productName.trim(),\n        size: size.trim(),\n        cases: parseInt(cases) || 0,\n        pieces: parseInt(pieces) || 0,\n        netLbs: parseFloat(netLbs) || 0,\n        revenue: parseFloat(revenue) || 0,\n        mfgItemNumber: mfgItemNumber.trim(),\n        customerId: currentCustomerId,\n        productCode: itemNumber.trim(),\n        period\n      };\n\n      records.push(record);\n      \n      if (!currentProducts.includes(productName.trim())) {\n        currentProducts.push(productName.trim());\n      }\n      continue;\n    }\n\n    // Check for alternative product line format (some items might have different spacing)\n    // Pattern without Net LBS: spaces + itemNumber + spaces + productName + spaces + size + spaces + cases + spaces + pieces + spaces + revenue + spaces + mfgItemNumber\n    const altProductMatch = line.match(/^\\s+(\\d+)\\s+(.+?)\\s+([A-Z0-9\\s\\/.-]+?)\\s+(\\d+)\\s+(\\d+)\\s+([0-9.-]+)\\s+([A-Z0-9\\s]+)$/);\n    if (altProductMatch && currentCustomer && !productMatch) {\n      const [, itemNumber, productName, size, cases, pieces, revenue, mfgItemNumber] = altProductMatch;\n      \n      const record: AlpineSalesRecord = {\n        customerName: currentCustomer,\n        productName: productName.trim(),\n        size: size.trim(),\n        cases: parseInt(cases) || 0,\n        pieces: parseInt(pieces) || 0,\n        netLbs: 0, // No Net LBS data in this format\n        revenue: parseFloat(revenue) || 0,\n        mfgItemNumber: mfgItemNumber.trim(),\n        customerId: currentCustomerId,\n        productCode: itemNumber.trim(),\n        period\n      };\n\n      records.push(record);\n      \n      if (!currentProducts.includes(productName.trim())) {\n        currentProducts.push(productName.trim());\n      }\n      continue;\n    }\n\n    // Check if this is a customer total line (skip it)\n    if (line.includes('CUSTOMER TOTAL :') || line.includes('RUN TOTALS :')) {\n      continue;\n    }\n  }\n\n  // Calculate metadata\n  const totalRevenue = records.reduce((sum, record) => sum + record.revenue, 0);\n  const totalCases = records.reduce((sum, record) => sum + record.cases, 0);\n  \n  const periodRevenue: Record<string, number> = {};\n  records.forEach(record => {\n    periodRevenue[record.period] = (periodRevenue[record.period] || 0) + record.revenue;\n  });\n\n  return {\n    records,\n    metadata: {\n      supplier,\n      periods: [period],\n      customers: Array.from(new Set(currentCustomers)),\n      products: Array.from(new Set(currentProducts)),\n      totalRevenue,\n      totalCases,\n      periodRevenue\n    }\n  };\n}\n\n/**\n * Parse multiple Alpine reports and combine them with period progression\n */\nexport function parseMultipleAlpineReports(\n  reports: Array<{ content: string; period: string }>\n): ParsedAlpineData {\n  const allRecords: AlpineSalesRecord[] = [];\n  const allCustomers = new Set<string>();\n  const allProducts = new Set<string>();\n  const allPeriods = new Set<string>();\n\n  for (const report of reports) {\n    const parsed = parseAlpineTXT(report.content, report.period);\n    allRecords.push(...parsed.records);\n    parsed.metadata.customers.forEach(c => allCustomers.add(c));\n    parsed.metadata.products.forEach(p => allProducts.add(p));\n    allPeriods.add(parsed.metadata.periods[0]);\n  }\n\n  const totalRevenue = allRecords.reduce((sum, record) => sum + record.revenue, 0);\n  const totalCases = allRecords.reduce((sum, record) => sum + record.cases, 0);\n\n  const periodRevenue: Record<string, number> = {};\n  allRecords.forEach(record => {\n    periodRevenue[record.period] = (periodRevenue[record.period] || 0) + record.revenue;\n  });\n\n  return {\n    records: allRecords.sort((a, b) => {\n      if (a.period !== b.period) return a.period.localeCompare(b.period);\n      if (a.customerName !== b.customerName) return a.customerName.localeCompare(b.customerName);\n      return a.productName.localeCompare(b.productName);\n    }),\n    metadata: {\n      supplier: 'ALPINE',\n      periods: Array.from(allPeriods).sort(),\n      customers: Array.from(allCustomers).sort(),\n      products: Array.from(allProducts).sort(),\n      totalRevenue,\n      totalCases,\n      periodRevenue\n    }\n  };\n}\n\n/**\n * Analyze customer progression across Alpine periods\n */\nexport interface CustomerProgressAnalysis {\n  customerName: string;\n  periods: Array<{\n    period: string;\n    totalRevenue: number;\n    totalCases: number;\n    productCount: number;\n    topProducts: Array<{ productName: string; revenue: number; cases: number }>;\n  }>;\n  trends: {\n    revenueTrend: 'increasing' | 'decreasing' | 'stable' | 'new';\n    caseTrend: 'increasing' | 'decreasing' | 'stable' | 'new';\n    productTrend: 'expanding' | 'contracting' | 'stable' | 'new';\n    status: 'active' | 'declining' | 'emerging' | 'lost';\n  };\n}\n\nexport function analyzeCustomerProgress(\n  records: AlpineSalesRecord[], \n  customerName: string\n): CustomerProgressAnalysis {\n  const customerRecords = records.filter(r => r.customerName === customerName);\n  \n  // Group by period\n  const periodData: Record<string, AlpineSalesRecord[]> = {};\n  customerRecords.forEach(record => {\n    if (!periodData[record.period]) {\n      periodData[record.period] = [];\n    }\n    periodData[record.period].push(record);\n  });\n\n  const periods = Object.entries(periodData)\n    .sort(([a], [b]) => a.localeCompare(b))\n    .map(([period, records]) => {\n      const productRevenue: Record<string, number> = {};\n      const productCases: Record<string, number> = {};\n      \n      records.forEach(record => {\n        productRevenue[record.productName] = (productRevenue[record.productName] || 0) + record.revenue;\n        productCases[record.productName] = (productCases[record.productName] || 0) + record.cases;\n      });\n\n      const topProducts = Object.entries(productRevenue)\n        .sort(([,a], [,b]) => b - a)\n        .slice(0, 5)\n        .map(([productName, revenue]) => ({\n          productName,\n          revenue,\n          cases: productCases[productName]\n        }));\n\n      return {\n        period,\n        totalRevenue: records.reduce((sum, r) => sum + r.revenue, 0),\n        totalCases: records.reduce((sum, r) => sum + r.cases, 0),\n        productCount: Object.keys(productRevenue).length,\n        topProducts\n      };\n    });\n\n  // Analyze trends\n  let revenueTrend: 'increasing' | 'decreasing' | 'stable' | 'new' = 'stable';\n  let caseTrend: 'increasing' | 'decreasing' | 'stable' | 'new' = 'stable';\n  let productTrend: 'expanding' | 'contracting' | 'stable' | 'new' = 'stable';\n\n  if (periods.length === 1) {\n    revenueTrend = 'new';\n    caseTrend = 'new';\n    productTrend = 'new';\n  } else if (periods.length >= 2) {\n    const latest = periods[periods.length - 1];\n    const previous = periods[periods.length - 2];\n    \n    const revenueChange = (latest.totalRevenue - previous.totalRevenue) / previous.totalRevenue;\n    const caseChange = (latest.totalCases - previous.totalCases) / previous.totalCases;\n    const productChange = latest.productCount - previous.productCount;\n    \n    revenueTrend = revenueChange > 0.1 ? 'increasing' : (revenueChange < -0.1 ? 'decreasing' : 'stable');\n    caseTrend = caseChange > 0.1 ? 'increasing' : (caseChange < -0.1 ? 'decreasing' : 'stable');\n    productTrend = productChange > 0 ? 'expanding' : (productChange < 0 ? 'contracting' : 'stable');\n  }\n\n  let status: 'active' | 'declining' | 'emerging' | 'lost' = 'active';\n  if (periods.length === 0) {\n    status = 'lost';\n  } else if (periods.length === 1 && revenueTrend === 'new') {\n    status = 'emerging';\n  } else if (revenueTrend === 'decreasing' || caseTrend === 'decreasing') {\n    status = 'declining';\n  } else if (revenueTrend === 'increasing' || caseTrend === 'increasing') {\n    status = 'active';\n  }\n\n  return {\n    customerName,\n    periods,\n    trends: {\n      revenueTrend,\n      caseTrend,\n      productTrend,\n      status\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}