{"ast":null,"code":"/**\n * Parse Alpine TXT sales report files\n * @param txtContent Raw TXT content as string\n * @param reportDate Report date to identify the period (format: YYYY-MM)\n * @returns Parsed Alpine sales data\n */\nexport function parseAlpineTXT(txtContent, reportDate) {\n  const lines = txtContent.split('\\n');\n  const records = [];\n  const supplier = 'ALPINE';\n\n  // Look for period information in the header\n  const headerLine = lines.find(line => line.includes('FROM :') && line.includes('THRU'));\n  let period = reportDate;\n  if (headerLine) {\n    const match = headerLine.match(/(\\d{1,2}\\/\\d{1,2}\\/\\d{2,4})/g);\n    if (match && match.length >= 2) {\n      const [, toDate] = match;\n      const [month, day, year] = toDate.includes('/') ? toDate.split('/') : ['', '', ''];\n      if (month && year) {\n        // Convert to YYYY-MM format\n        const fullYear = year.length === 2 ? `20${year}` : year;\n        period = `${fullYear}-${month.padStart(2, '0')}`;\n      }\n    }\n  }\n\n  // Find customers and their purchases\n  let currentCustomer = '';\n  let currentCustomerId = '';\n  let currentCustomers = [];\n  let currentProducts = [];\n  for (let i = 0; i < lines.length; i++) {\n    const originalLine = lines[i];\n    const line = originalLine.trim();\n\n    // Skip empty lines and headers\n    if (!line || line.startsWith('IT415V') || line.startsWith('SALES RECAP') || line.startsWith('FROM :') || line.startsWith('RUN DATE') || line.startsWith('GALANT GALANT') || line.startsWith('ALPINE') || line.startsWith('DESCRIPTION') || line.startsWith('-----------') || line === 'SALES' || line.includes('MFG ITEM #')) {\n      continue;\n    }\n\n    // Check if this is a customer line (starts with customer number and description)\n    // Updated regex to handle both 4-digit and 5-digit customer numbers\n    const customerMatch = line.match(/^\\s*(\\d{4,5}-\\d{3})\\s+(.+)/);\n    if (customerMatch) {\n      const [, customerId, customerDescription] = customerMatch;\n      currentCustomer = customerDescription.trim();\n      currentCustomerId = customerId.trim();\n      currentCustomers.push(currentCustomer);\n      continue;\n    }\n\n    // Check if this is a product line (indented with spaces at the beginning)\n    // Use a more flexible approach to handle variable spacing\n    if (originalLine.startsWith('    ') && /^\\s+\\d+/.test(originalLine) && currentCustomer) {\n      // Don't trim the line yet - we need to preserve the original spacing for parsing\n      const parts = originalLine.split(/\\s+/);\n\n      // Look for pattern: itemNumber productName size cases pieces netLbs revenue mfgItemNumber\n      // Use the same logic that worked for the June file\n      if (parts.length >= 7 && /^\\d+$/.test(parts[1])) {\n        const itemNumber = parts[1];\n\n        // Find the size field (look for patterns like \"12 CT\", \"12/4 OZ\", etc.)\n        let sizeIndex = -1;\n        for (let i = 2; i < parts.length; i++) {\n          if (parts[i].match(/^\\d+/) && (parts[i + 1] === 'CT' || parts[i + 1] === 'OZ' || parts[i].includes('/'))) {\n            sizeIndex = i;\n            break;\n          }\n        }\n        if (sizeIndex === -1) continue; // Skip if we can't find size\n\n        const productName = parts.slice(2, sizeIndex).join(' ');\n        const size = parts[sizeIndex] + (parts[sizeIndex + 1] && (parts[sizeIndex + 1] === 'CT' || parts[sizeIndex + 1] === 'OZ') ? ' ' + parts[sizeIndex + 1] : '');\n\n        // Find the cases field (first numeric field after size)\n        let casesIndex = sizeIndex + (parts[sizeIndex + 1] && (parts[sizeIndex + 1] === 'CT' || parts[sizeIndex + 1] === 'OZ') ? 2 : 1);\n        const cases = parts[casesIndex] || '0';\n\n        // Find pieces field (next numeric field)\n        let piecesIndex = casesIndex + 1;\n        const pieces = parts[piecesIndex] || '0';\n\n        // Find revenue field (next numeric field - there's no separate netLbs field)\n        let revenueIndex = piecesIndex + 1;\n        let revenue = parts[revenueIndex] || '0';\n        if (revenue.endsWith('-')) {\n          revenue = '-' + revenue.slice(0, -1);\n        }\n\n        // Find mfg item number (everything after revenue)\n        const mfgItemNumber = parts.slice(revenueIndex + 1).join(' ').trim();\n\n        // Set netLbs to 0 since it's not in the file format\n        const netLbs = '0';\n        const record = {\n          period: period,\n          customerName: currentCustomer,\n          productName: productName.trim(),\n          size: size.trim(),\n          customerId: currentCustomerId,\n          productCode: itemNumber.trim(),\n          cases: parseInt(cases) || 0,\n          pieces: parseFloat(pieces) || 0,\n          netLbs: parseFloat(netLbs) || 0,\n          revenue: parseFloat(revenue) || 0,\n          mfgItemNumber: mfgItemNumber.trim()\n        };\n        records.push(record);\n        if (!currentProducts.includes(productName.trim())) {\n          currentProducts.push(productName.trim());\n        }\n        continue;\n      }\n    }\n\n    // Check if this is a customer total line (skip it)\n    if (line.includes('CUSTOMER TOTAL :') || line.includes('RUN TOTALS :')) {\n      continue;\n    }\n  }\n\n  // Calculate metadata\n  const totalRevenue = records.reduce((sum, record) => sum + record.revenue, 0);\n  const totalCases = records.reduce((sum, record) => sum + record.cases, 0);\n  const periodRevenue = {};\n  records.forEach(record => {\n    periodRevenue[record.period] = (periodRevenue[record.period] || 0) + record.revenue;\n  });\n  return {\n    records,\n    metadata: {\n      supplier,\n      periods: [period],\n      customers: Array.from(new Set(currentCustomers)),\n      products: Array.from(new Set(currentProducts)),\n      totalRevenue,\n      totalCases,\n      periodRevenue\n    }\n  };\n}\n\n/**\n * Parse multiple Alpine reports and combine them with period progression\n */\nexport function parseMultipleAlpineReports(reports) {\n  const allRecords = [];\n  const allCustomers = new Set();\n  const allProducts = new Set();\n  const allPeriods = new Set();\n  for (const report of reports) {\n    const parsed = parseAlpineTXT(report.content, report.period);\n    allRecords.push(...parsed.records);\n    parsed.metadata.customers.forEach(c => allCustomers.add(c));\n    parsed.metadata.products.forEach(p => allProducts.add(p));\n    allPeriods.add(parsed.metadata.periods[0]);\n  }\n  const totalRevenue = allRecords.reduce((sum, record) => sum + record.revenue, 0);\n  const totalCases = allRecords.reduce((sum, record) => sum + record.cases, 0);\n  const periodRevenue = {};\n  allRecords.forEach(record => {\n    periodRevenue[record.period] = (periodRevenue[record.period] || 0) + record.revenue;\n  });\n  return {\n    records: allRecords.sort((a, b) => {\n      if (a.period !== b.period) return a.period.localeCompare(b.period);\n      if (a.customerName !== b.customerName) return a.customerName.localeCompare(b.customerName);\n      return a.productName.localeCompare(b.productName);\n    }),\n    metadata: {\n      supplier: 'ALPINE',\n      periods: Array.from(allPeriods).sort(),\n      customers: Array.from(allCustomers).sort(),\n      products: Array.from(allProducts).sort(),\n      totalRevenue,\n      totalCases,\n      periodRevenue\n    }\n  };\n}\n\n/**\n * Analyze customer progression across Alpine periods\n */\n\nexport function analyzeCustomerProgress(records, customerName) {\n  const customerRecords = records.filter(r => r.customerName === customerName);\n\n  // Group by period\n  const periodData = {};\n  customerRecords.forEach(record => {\n    if (!periodData[record.period]) {\n      periodData[record.period] = [];\n    }\n    periodData[record.period].push(record);\n  });\n  const periods = Object.entries(periodData).sort(([a], [b]) => a.localeCompare(b)).map(([period, records]) => {\n    const productRevenue = {};\n    const productCases = {};\n    records.forEach(record => {\n      productRevenue[record.productName] = (productRevenue[record.productName] || 0) + record.revenue;\n      productCases[record.productName] = (productCases[record.productName] || 0) + record.cases;\n    });\n    const topProducts = Object.entries(productRevenue).sort(([, a], [, b]) => b - a).slice(0, 5).map(([productName, revenue]) => ({\n      productName,\n      revenue,\n      cases: productCases[productName]\n    }));\n    return {\n      period,\n      totalRevenue: records.reduce((sum, r) => sum + r.revenue, 0),\n      totalCases: records.reduce((sum, r) => sum + r.cases, 0),\n      productCount: Object.keys(productRevenue).length,\n      topProducts\n    };\n  });\n\n  // Analyze trends\n  let revenueTrend = 'stable';\n  let caseTrend = 'stable';\n  let productTrend = 'stable';\n  if (periods.length === 1) {\n    revenueTrend = 'new';\n    caseTrend = 'new';\n    productTrend = 'new';\n  } else if (periods.length >= 2) {\n    const latest = periods[periods.length - 1];\n    const previous = periods[periods.length - 2];\n    const revenueChange = (latest.totalRevenue - previous.totalRevenue) / previous.totalRevenue;\n    const caseChange = (latest.totalCases - previous.totalCases) / previous.totalCases;\n    const productChange = latest.productCount - previous.productCount;\n    revenueTrend = revenueChange > 0.1 ? 'increasing' : revenueChange < -0.1 ? 'decreasing' : 'stable';\n    caseTrend = caseChange > 0.1 ? 'increasing' : caseChange < -0.1 ? 'decreasing' : 'stable';\n    productTrend = productChange > 0 ? 'expanding' : productChange < 0 ? 'contracting' : 'stable';\n  }\n  let status = 'active';\n  if (periods.length === 0) {\n    status = 'lost';\n  } else if (periods.length === 1 && revenueTrend === 'new') {\n    status = 'emerging';\n  } else if (revenueTrend === 'decreasing' || caseTrend === 'decreasing') {\n    status = 'declining';\n  } else if (revenueTrend === 'increasing' || caseTrend === 'increasing') {\n    status = 'active';\n  }\n  return {\n    customerName,\n    periods,\n    trends: {\n      revenueTrend,\n      caseTrend,\n      productTrend,\n      status\n    }\n  };\n}","map":{"version":3,"names":["parseAlpineTXT","txtContent","reportDate","lines","split","records","supplier","headerLine","find","line","includes","period","match","length","toDate","month","day","year","fullYear","padStart","currentCustomer","currentCustomerId","currentCustomers","currentProducts","i","originalLine","trim","startsWith","customerMatch","customerId","customerDescription","push","test","parts","itemNumber","sizeIndex","productName","slice","join","size","casesIndex","cases","piecesIndex","pieces","revenueIndex","revenue","endsWith","mfgItemNumber","netLbs","record","customerName","productCode","parseInt","parseFloat","totalRevenue","reduce","sum","totalCases","periodRevenue","forEach","metadata","periods","customers","Array","from","Set","products","parseMultipleAlpineReports","reports","allRecords","allCustomers","allProducts","allPeriods","report","parsed","content","c","add","p","sort","a","b","localeCompare","analyzeCustomerProgress","customerRecords","filter","r","periodData","Object","entries","map","productRevenue","productCases","topProducts","productCount","keys","revenueTrend","caseTrend","productTrend","latest","previous","revenueChange","caseChange","productChange","status","trends"],"sources":["/Users/isaachirsch/Desktop/GalantCo/SalesTracker/src/utils/alpineParser.ts"],"sourcesContent":["export interface AlpineSalesRecord {\n  customerName: string;\n  productName: string;\n  size?: string;\n  cases: number;\n  pieces: number;\n  netLbs?: number;\n  revenue: number;\n  mfgItemNumber?: string;\n  period: string; // e.g., \"2025-06\", \"2025-07\", \"2025-08\"\n  customerId?: string;\n  productCode?: string;\n}\n\nexport interface ParsedAlpineData {\n  records: AlpineSalesRecord[];\n  metadata: {\n    supplier: string;\n    periods: string[];\n    customers: string[];\n    products: string[];\n    totalRevenue: number;\n    totalCases: number;\n    periodRevenue: Record<string, number>;\n  };\n}\n\n/**\n * Parse Alpine TXT sales report files\n * @param txtContent Raw TXT content as string\n * @param reportDate Report date to identify the period (format: YYYY-MM)\n * @returns Parsed Alpine sales data\n */\nexport function parseAlpineTXT(txtContent: string, reportDate: string): ParsedAlpineData {\n  const lines = txtContent.split('\\n');\n  const records: AlpineSalesRecord[] = [];\n  const supplier = 'ALPINE';\n  \n  \n  // Look for period information in the header\n  const headerLine = lines.find(line => line.includes('FROM :') && line.includes('THRU'));\n  let period = reportDate;\n  if (headerLine) {\n    const match = headerLine.match(/(\\d{1,2}\\/\\d{1,2}\\/\\d{2,4})/g);\n    if (match && match.length >= 2) {\n      const [, toDate] = match;\n      const [month, day, year] = toDate.includes('/') ? toDate.split('/') : ['', '', ''];\n      if (month && year) {\n        // Convert to YYYY-MM format\n        const fullYear = year.length === 2 ? `20${year}` : year;\n        period = `${fullYear}-${month.padStart(2, '0')}`;\n      }\n    }\n  }\n\n  // Find customers and their purchases\n  let currentCustomer = '';\n  let currentCustomerId = '';\n  let currentCustomers: string[] = [];\n  let currentProducts: string[] = [];\n\n  for (let i = 0; i < lines.length; i++) {\n    const originalLine = lines[i];\n    const line = originalLine.trim();\n    \n    // Skip empty lines and headers\n    if (!line || line.startsWith('IT415V') || line.startsWith('SALES RECAP') || \n        line.startsWith('FROM :') || line.startsWith('RUN DATE') || \n        line.startsWith('GALANT GALANT') || line.startsWith('ALPINE') ||\n        line.startsWith('DESCRIPTION') || line.startsWith('-----------') ||\n        line === 'SALES' || line.includes('MFG ITEM #')) {\n      continue;\n    }\n\n\n    // Check if this is a customer line (starts with customer number and description)\n    // Updated regex to handle both 4-digit and 5-digit customer numbers\n    const customerMatch = line.match(/^\\s*(\\d{4,5}-\\d{3})\\s+(.+)/);\n    if (customerMatch) {\n      const [, customerId, customerDescription] = customerMatch;\n      currentCustomer = customerDescription.trim();\n      currentCustomerId = customerId.trim();\n      currentCustomers.push(currentCustomer);\n      continue;\n    }\n\n    // Check if this is a product line (indented with spaces at the beginning)\n    // Use a more flexible approach to handle variable spacing\n    if (originalLine.startsWith('    ') && /^\\s+\\d+/.test(originalLine) && currentCustomer) {\n      // Don't trim the line yet - we need to preserve the original spacing for parsing\n      const parts = originalLine.split(/\\s+/);\n      \n      // Look for pattern: itemNumber productName size cases pieces netLbs revenue mfgItemNumber\n      // Use the same logic that worked for the June file\n      if (parts.length >= 7 && /^\\d+$/.test(parts[1])) {\n        const itemNumber = parts[1];\n        \n        // Find the size field (look for patterns like \"12 CT\", \"12/4 OZ\", etc.)\n        let sizeIndex = -1;\n        for (let i = 2; i < parts.length; i++) {\n          if (parts[i].match(/^\\d+/) && (parts[i+1] === 'CT' || parts[i+1] === 'OZ' || parts[i].includes('/'))) {\n            sizeIndex = i;\n            break;\n          }\n        }\n        \n        if (sizeIndex === -1) continue; // Skip if we can't find size\n        \n        const productName = parts.slice(2, sizeIndex).join(' ');\n        const size = parts[sizeIndex] + (parts[sizeIndex + 1] && (parts[sizeIndex + 1] === 'CT' || parts[sizeIndex + 1] === 'OZ') ? ' ' + parts[sizeIndex + 1] : '');\n        \n        // Find the cases field (first numeric field after size)\n        let casesIndex = sizeIndex + (parts[sizeIndex + 1] && (parts[sizeIndex + 1] === 'CT' || parts[sizeIndex + 1] === 'OZ') ? 2 : 1);\n        const cases = parts[casesIndex] || '0';\n        \n        // Find pieces field (next numeric field)\n        let piecesIndex = casesIndex + 1;\n        const pieces = parts[piecesIndex] || '0';\n        \n        // Find revenue field (next numeric field - there's no separate netLbs field)\n        let revenueIndex = piecesIndex + 1;\n        let revenue = parts[revenueIndex] || '0';\n        if (revenue.endsWith('-')) {\n          revenue = '-' + revenue.slice(0, -1);\n        }\n        \n        // Find mfg item number (everything after revenue)\n        const mfgItemNumber = parts.slice(revenueIndex + 1).join(' ').trim();\n        \n        // Set netLbs to 0 since it's not in the file format\n        const netLbs = '0';\n        \n        \n        const record: AlpineSalesRecord = {\n          period: period,\n          customerName: currentCustomer,\n          productName: productName.trim(),\n          size: size.trim(),\n          customerId: currentCustomerId,\n          productCode: itemNumber.trim(),\n          cases: parseInt(cases) || 0,\n          pieces: parseFloat(pieces) || 0,\n          netLbs: parseFloat(netLbs) || 0,\n          revenue: parseFloat(revenue) || 0,\n          mfgItemNumber: mfgItemNumber.trim()\n        };\n\n        records.push(record);\n        \n        if (!currentProducts.includes(productName.trim())) {\n          currentProducts.push(productName.trim());\n        }\n        continue;\n      }\n    }\n\n    // Check if this is a customer total line (skip it)\n    if (line.includes('CUSTOMER TOTAL :') || line.includes('RUN TOTALS :')) {\n      continue;\n    }\n  }\n\n  // Calculate metadata\n  const totalRevenue = records.reduce((sum, record) => sum + record.revenue, 0);\n  const totalCases = records.reduce((sum, record) => sum + record.cases, 0);\n  \n  const periodRevenue: Record<string, number> = {};\n  records.forEach(record => {\n    periodRevenue[record.period] = (periodRevenue[record.period] || 0) + record.revenue;\n  });\n\n\n  return {\n    records,\n    metadata: {\n      supplier,\n      periods: [period],\n      customers: Array.from(new Set(currentCustomers)),\n      products: Array.from(new Set(currentProducts)),\n      totalRevenue,\n      totalCases,\n      periodRevenue\n    }\n  };\n}\n\n/**\n * Parse multiple Alpine reports and combine them with period progression\n */\nexport function parseMultipleAlpineReports(\n  reports: Array<{ content: string; period: string }>\n): ParsedAlpineData {\n  const allRecords: AlpineSalesRecord[] = [];\n  const allCustomers = new Set<string>();\n  const allProducts = new Set<string>();\n  const allPeriods = new Set<string>();\n\n  for (const report of reports) {\n    const parsed = parseAlpineTXT(report.content, report.period);\n    allRecords.push(...parsed.records);\n    parsed.metadata.customers.forEach(c => allCustomers.add(c));\n    parsed.metadata.products.forEach(p => allProducts.add(p));\n    allPeriods.add(parsed.metadata.periods[0]);\n  }\n\n  const totalRevenue = allRecords.reduce((sum, record) => sum + record.revenue, 0);\n  const totalCases = allRecords.reduce((sum, record) => sum + record.cases, 0);\n\n  const periodRevenue: Record<string, number> = {};\n  allRecords.forEach(record => {\n    periodRevenue[record.period] = (periodRevenue[record.period] || 0) + record.revenue;\n  });\n\n  return {\n    records: allRecords.sort((a, b) => {\n      if (a.period !== b.period) return a.period.localeCompare(b.period);\n      if (a.customerName !== b.customerName) return a.customerName.localeCompare(b.customerName);\n      return a.productName.localeCompare(b.productName);\n    }),\n    metadata: {\n      supplier: 'ALPINE',\n      periods: Array.from(allPeriods).sort(),\n      customers: Array.from(allCustomers).sort(),\n      products: Array.from(allProducts).sort(),\n      totalRevenue,\n      totalCases,\n      periodRevenue\n    }\n  };\n}\n\n/**\n * Analyze customer progression across Alpine periods\n */\nexport interface CustomerProgressAnalysis {\n  customerName: string;\n  periods: Array<{\n    period: string;\n    totalRevenue: number;\n    totalCases: number;\n    productCount: number;\n    topProducts: Array<{ productName: string; revenue: number; cases: number }>;\n  }>;\n  trends: {\n    revenueTrend: 'increasing' | 'decreasing' | 'stable' | 'new';\n    caseTrend: 'increasing' | 'decreasing' | 'stable' | 'new';\n    productTrend: 'expanding' | 'contracting' | 'stable' | 'new';\n    status: 'active' | 'declining' | 'emerging' | 'lost';\n  };\n}\n\nexport function analyzeCustomerProgress(\n  records: AlpineSalesRecord[], \n  customerName: string\n): CustomerProgressAnalysis {\n  const customerRecords = records.filter(r => r.customerName === customerName);\n  \n  // Group by period\n  const periodData: Record<string, AlpineSalesRecord[]> = {};\n  customerRecords.forEach(record => {\n    if (!periodData[record.period]) {\n      periodData[record.period] = [];\n    }\n    periodData[record.period].push(record);\n  });\n\n  const periods = Object.entries(periodData)\n    .sort(([a], [b]) => a.localeCompare(b))\n    .map(([period, records]) => {\n      const productRevenue: Record<string, number> = {};\n      const productCases: Record<string, number> = {};\n      \n      records.forEach(record => {\n        productRevenue[record.productName] = (productRevenue[record.productName] || 0) + record.revenue;\n        productCases[record.productName] = (productCases[record.productName] || 0) + record.cases;\n      });\n\n      const topProducts = Object.entries(productRevenue)\n        .sort(([,a], [,b]) => b - a)\n        .slice(0, 5)\n        .map(([productName, revenue]) => ({\n          productName,\n          revenue,\n          cases: productCases[productName]\n        }));\n\n      return {\n        period,\n        totalRevenue: records.reduce((sum, r) => sum + r.revenue, 0),\n        totalCases: records.reduce((sum, r) => sum + r.cases, 0),\n        productCount: Object.keys(productRevenue).length,\n        topProducts\n      };\n    });\n\n  // Analyze trends\n  let revenueTrend: 'increasing' | 'decreasing' | 'stable' | 'new' = 'stable';\n  let caseTrend: 'increasing' | 'decreasing' | 'stable' | 'new' = 'stable';\n  let productTrend: 'expanding' | 'contracting' | 'stable' | 'new' = 'stable';\n\n  if (periods.length === 1) {\n    revenueTrend = 'new';\n    caseTrend = 'new';\n    productTrend = 'new';\n  } else if (periods.length >= 2) {\n    const latest = periods[periods.length - 1];\n    const previous = periods[periods.length - 2];\n    \n    const revenueChange = (latest.totalRevenue - previous.totalRevenue) / previous.totalRevenue;\n    const caseChange = (latest.totalCases - previous.totalCases) / previous.totalCases;\n    const productChange = latest.productCount - previous.productCount;\n    \n    revenueTrend = revenueChange > 0.1 ? 'increasing' : (revenueChange < -0.1 ? 'decreasing' : 'stable');\n    caseTrend = caseChange > 0.1 ? 'increasing' : (caseChange < -0.1 ? 'decreasing' : 'stable');\n    productTrend = productChange > 0 ? 'expanding' : (productChange < 0 ? 'contracting' : 'stable');\n  }\n\n  let status: 'active' | 'declining' | 'emerging' | 'lost' = 'active';\n  if (periods.length === 0) {\n    status = 'lost';\n  } else if (periods.length === 1 && revenueTrend === 'new') {\n    status = 'emerging';\n  } else if (revenueTrend === 'decreasing' || caseTrend === 'decreasing') {\n    status = 'declining';\n  } else if (revenueTrend === 'increasing' || caseTrend === 'increasing') {\n    status = 'active';\n  }\n\n  return {\n    customerName,\n    periods,\n    trends: {\n      revenueTrend,\n      caseTrend,\n      productTrend,\n      status\n    }\n  };\n}\n"],"mappings":"AA2BA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,cAAcA,CAACC,UAAkB,EAAEC,UAAkB,EAAoB;EACvF,MAAMC,KAAK,GAAGF,UAAU,CAACG,KAAK,CAAC,IAAI,CAAC;EACpC,MAAMC,OAA4B,GAAG,EAAE;EACvC,MAAMC,QAAQ,GAAG,QAAQ;;EAGzB;EACA,MAAMC,UAAU,GAAGJ,KAAK,CAACK,IAAI,CAACC,IAAI,IAAIA,IAAI,CAACC,QAAQ,CAAC,QAAQ,CAAC,IAAID,IAAI,CAACC,QAAQ,CAAC,MAAM,CAAC,CAAC;EACvF,IAAIC,MAAM,GAAGT,UAAU;EACvB,IAAIK,UAAU,EAAE;IACd,MAAMK,KAAK,GAAGL,UAAU,CAACK,KAAK,CAAC,8BAA8B,CAAC;IAC9D,IAAIA,KAAK,IAAIA,KAAK,CAACC,MAAM,IAAI,CAAC,EAAE;MAC9B,MAAM,GAAGC,MAAM,CAAC,GAAGF,KAAK;MACxB,MAAM,CAACG,KAAK,EAAEC,GAAG,EAAEC,IAAI,CAAC,GAAGH,MAAM,CAACJ,QAAQ,CAAC,GAAG,CAAC,GAAGI,MAAM,CAACV,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC;MAClF,IAAIW,KAAK,IAAIE,IAAI,EAAE;QACjB;QACA,MAAMC,QAAQ,GAAGD,IAAI,CAACJ,MAAM,KAAK,CAAC,GAAG,KAAKI,IAAI,EAAE,GAAGA,IAAI;QACvDN,MAAM,GAAG,GAAGO,QAAQ,IAAIH,KAAK,CAACI,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,EAAE;MAClD;IACF;EACF;;EAEA;EACA,IAAIC,eAAe,GAAG,EAAE;EACxB,IAAIC,iBAAiB,GAAG,EAAE;EAC1B,IAAIC,gBAA0B,GAAG,EAAE;EACnC,IAAIC,eAAyB,GAAG,EAAE;EAElC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGrB,KAAK,CAACU,MAAM,EAAEW,CAAC,EAAE,EAAE;IACrC,MAAMC,YAAY,GAAGtB,KAAK,CAACqB,CAAC,CAAC;IAC7B,MAAMf,IAAI,GAAGgB,YAAY,CAACC,IAAI,CAAC,CAAC;;IAEhC;IACA,IAAI,CAACjB,IAAI,IAAIA,IAAI,CAACkB,UAAU,CAAC,QAAQ,CAAC,IAAIlB,IAAI,CAACkB,UAAU,CAAC,aAAa,CAAC,IACpElB,IAAI,CAACkB,UAAU,CAAC,QAAQ,CAAC,IAAIlB,IAAI,CAACkB,UAAU,CAAC,UAAU,CAAC,IACxDlB,IAAI,CAACkB,UAAU,CAAC,eAAe,CAAC,IAAIlB,IAAI,CAACkB,UAAU,CAAC,QAAQ,CAAC,IAC7DlB,IAAI,CAACkB,UAAU,CAAC,aAAa,CAAC,IAAIlB,IAAI,CAACkB,UAAU,CAAC,aAAa,CAAC,IAChElB,IAAI,KAAK,OAAO,IAAIA,IAAI,CAACC,QAAQ,CAAC,YAAY,CAAC,EAAE;MACnD;IACF;;IAGA;IACA;IACA,MAAMkB,aAAa,GAAGnB,IAAI,CAACG,KAAK,CAAC,4BAA4B,CAAC;IAC9D,IAAIgB,aAAa,EAAE;MACjB,MAAM,GAAGC,UAAU,EAAEC,mBAAmB,CAAC,GAAGF,aAAa;MACzDR,eAAe,GAAGU,mBAAmB,CAACJ,IAAI,CAAC,CAAC;MAC5CL,iBAAiB,GAAGQ,UAAU,CAACH,IAAI,CAAC,CAAC;MACrCJ,gBAAgB,CAACS,IAAI,CAACX,eAAe,CAAC;MACtC;IACF;;IAEA;IACA;IACA,IAAIK,YAAY,CAACE,UAAU,CAAC,MAAM,CAAC,IAAI,SAAS,CAACK,IAAI,CAACP,YAAY,CAAC,IAAIL,eAAe,EAAE;MACtF;MACA,MAAMa,KAAK,GAAGR,YAAY,CAACrB,KAAK,CAAC,KAAK,CAAC;;MAEvC;MACA;MACA,IAAI6B,KAAK,CAACpB,MAAM,IAAI,CAAC,IAAI,OAAO,CAACmB,IAAI,CAACC,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE;QAC/C,MAAMC,UAAU,GAAGD,KAAK,CAAC,CAAC,CAAC;;QAE3B;QACA,IAAIE,SAAS,GAAG,CAAC,CAAC;QAClB,KAAK,IAAIX,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGS,KAAK,CAACpB,MAAM,EAAEW,CAAC,EAAE,EAAE;UACrC,IAAIS,KAAK,CAACT,CAAC,CAAC,CAACZ,KAAK,CAAC,MAAM,CAAC,KAAKqB,KAAK,CAACT,CAAC,GAAC,CAAC,CAAC,KAAK,IAAI,IAAIS,KAAK,CAACT,CAAC,GAAC,CAAC,CAAC,KAAK,IAAI,IAAIS,KAAK,CAACT,CAAC,CAAC,CAACd,QAAQ,CAAC,GAAG,CAAC,CAAC,EAAE;YACpGyB,SAAS,GAAGX,CAAC;YACb;UACF;QACF;QAEA,IAAIW,SAAS,KAAK,CAAC,CAAC,EAAE,SAAS,CAAC;;QAEhC,MAAMC,WAAW,GAAGH,KAAK,CAACI,KAAK,CAAC,CAAC,EAAEF,SAAS,CAAC,CAACG,IAAI,CAAC,GAAG,CAAC;QACvD,MAAMC,IAAI,GAAGN,KAAK,CAACE,SAAS,CAAC,IAAIF,KAAK,CAACE,SAAS,GAAG,CAAC,CAAC,KAAKF,KAAK,CAACE,SAAS,GAAG,CAAC,CAAC,KAAK,IAAI,IAAIF,KAAK,CAACE,SAAS,GAAG,CAAC,CAAC,KAAK,IAAI,CAAC,GAAG,GAAG,GAAGF,KAAK,CAACE,SAAS,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC;;QAE5J;QACA,IAAIK,UAAU,GAAGL,SAAS,IAAIF,KAAK,CAACE,SAAS,GAAG,CAAC,CAAC,KAAKF,KAAK,CAACE,SAAS,GAAG,CAAC,CAAC,KAAK,IAAI,IAAIF,KAAK,CAACE,SAAS,GAAG,CAAC,CAAC,KAAK,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QAC/H,MAAMM,KAAK,GAAGR,KAAK,CAACO,UAAU,CAAC,IAAI,GAAG;;QAEtC;QACA,IAAIE,WAAW,GAAGF,UAAU,GAAG,CAAC;QAChC,MAAMG,MAAM,GAAGV,KAAK,CAACS,WAAW,CAAC,IAAI,GAAG;;QAExC;QACA,IAAIE,YAAY,GAAGF,WAAW,GAAG,CAAC;QAClC,IAAIG,OAAO,GAAGZ,KAAK,CAACW,YAAY,CAAC,IAAI,GAAG;QACxC,IAAIC,OAAO,CAACC,QAAQ,CAAC,GAAG,CAAC,EAAE;UACzBD,OAAO,GAAG,GAAG,GAAGA,OAAO,CAACR,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QACtC;;QAEA;QACA,MAAMU,aAAa,GAAGd,KAAK,CAACI,KAAK,CAACO,YAAY,GAAG,CAAC,CAAC,CAACN,IAAI,CAAC,GAAG,CAAC,CAACZ,IAAI,CAAC,CAAC;;QAEpE;QACA,MAAMsB,MAAM,GAAG,GAAG;QAGlB,MAAMC,MAAyB,GAAG;UAChCtC,MAAM,EAAEA,MAAM;UACduC,YAAY,EAAE9B,eAAe;UAC7BgB,WAAW,EAAEA,WAAW,CAACV,IAAI,CAAC,CAAC;UAC/Ba,IAAI,EAAEA,IAAI,CAACb,IAAI,CAAC,CAAC;UACjBG,UAAU,EAAER,iBAAiB;UAC7B8B,WAAW,EAAEjB,UAAU,CAACR,IAAI,CAAC,CAAC;UAC9Be,KAAK,EAAEW,QAAQ,CAACX,KAAK,CAAC,IAAI,CAAC;UAC3BE,MAAM,EAAEU,UAAU,CAACV,MAAM,CAAC,IAAI,CAAC;UAC/BK,MAAM,EAAEK,UAAU,CAACL,MAAM,CAAC,IAAI,CAAC;UAC/BH,OAAO,EAAEQ,UAAU,CAACR,OAAO,CAAC,IAAI,CAAC;UACjCE,aAAa,EAAEA,aAAa,CAACrB,IAAI,CAAC;QACpC,CAAC;QAEDrB,OAAO,CAAC0B,IAAI,CAACkB,MAAM,CAAC;QAEpB,IAAI,CAAC1B,eAAe,CAACb,QAAQ,CAAC0B,WAAW,CAACV,IAAI,CAAC,CAAC,CAAC,EAAE;UACjDH,eAAe,CAACQ,IAAI,CAACK,WAAW,CAACV,IAAI,CAAC,CAAC,CAAC;QAC1C;QACA;MACF;IACF;;IAEA;IACA,IAAIjB,IAAI,CAACC,QAAQ,CAAC,kBAAkB,CAAC,IAAID,IAAI,CAACC,QAAQ,CAAC,cAAc,CAAC,EAAE;MACtE;IACF;EACF;;EAEA;EACA,MAAM4C,YAAY,GAAGjD,OAAO,CAACkD,MAAM,CAAC,CAACC,GAAG,EAAEP,MAAM,KAAKO,GAAG,GAAGP,MAAM,CAACJ,OAAO,EAAE,CAAC,CAAC;EAC7E,MAAMY,UAAU,GAAGpD,OAAO,CAACkD,MAAM,CAAC,CAACC,GAAG,EAAEP,MAAM,KAAKO,GAAG,GAAGP,MAAM,CAACR,KAAK,EAAE,CAAC,CAAC;EAEzE,MAAMiB,aAAqC,GAAG,CAAC,CAAC;EAChDrD,OAAO,CAACsD,OAAO,CAACV,MAAM,IAAI;IACxBS,aAAa,CAACT,MAAM,CAACtC,MAAM,CAAC,GAAG,CAAC+C,aAAa,CAACT,MAAM,CAACtC,MAAM,CAAC,IAAI,CAAC,IAAIsC,MAAM,CAACJ,OAAO;EACrF,CAAC,CAAC;EAGF,OAAO;IACLxC,OAAO;IACPuD,QAAQ,EAAE;MACRtD,QAAQ;MACRuD,OAAO,EAAE,CAAClD,MAAM,CAAC;MACjBmD,SAAS,EAAEC,KAAK,CAACC,IAAI,CAAC,IAAIC,GAAG,CAAC3C,gBAAgB,CAAC,CAAC;MAChD4C,QAAQ,EAAEH,KAAK,CAACC,IAAI,CAAC,IAAIC,GAAG,CAAC1C,eAAe,CAAC,CAAC;MAC9C+B,YAAY;MACZG,UAAU;MACVC;IACF;EACF,CAAC;AACH;;AAEA;AACA;AACA;AACA,OAAO,SAASS,0BAA0BA,CACxCC,OAAmD,EACjC;EAClB,MAAMC,UAA+B,GAAG,EAAE;EAC1C,MAAMC,YAAY,GAAG,IAAIL,GAAG,CAAS,CAAC;EACtC,MAAMM,WAAW,GAAG,IAAIN,GAAG,CAAS,CAAC;EACrC,MAAMO,UAAU,GAAG,IAAIP,GAAG,CAAS,CAAC;EAEpC,KAAK,MAAMQ,MAAM,IAAIL,OAAO,EAAE;IAC5B,MAAMM,MAAM,GAAG1E,cAAc,CAACyE,MAAM,CAACE,OAAO,EAAEF,MAAM,CAAC9D,MAAM,CAAC;IAC5D0D,UAAU,CAACtC,IAAI,CAAC,GAAG2C,MAAM,CAACrE,OAAO,CAAC;IAClCqE,MAAM,CAACd,QAAQ,CAACE,SAAS,CAACH,OAAO,CAACiB,CAAC,IAAIN,YAAY,CAACO,GAAG,CAACD,CAAC,CAAC,CAAC;IAC3DF,MAAM,CAACd,QAAQ,CAACM,QAAQ,CAACP,OAAO,CAACmB,CAAC,IAAIP,WAAW,CAACM,GAAG,CAACC,CAAC,CAAC,CAAC;IACzDN,UAAU,CAACK,GAAG,CAACH,MAAM,CAACd,QAAQ,CAACC,OAAO,CAAC,CAAC,CAAC,CAAC;EAC5C;EAEA,MAAMP,YAAY,GAAGe,UAAU,CAACd,MAAM,CAAC,CAACC,GAAG,EAAEP,MAAM,KAAKO,GAAG,GAAGP,MAAM,CAACJ,OAAO,EAAE,CAAC,CAAC;EAChF,MAAMY,UAAU,GAAGY,UAAU,CAACd,MAAM,CAAC,CAACC,GAAG,EAAEP,MAAM,KAAKO,GAAG,GAAGP,MAAM,CAACR,KAAK,EAAE,CAAC,CAAC;EAE5E,MAAMiB,aAAqC,GAAG,CAAC,CAAC;EAChDW,UAAU,CAACV,OAAO,CAACV,MAAM,IAAI;IAC3BS,aAAa,CAACT,MAAM,CAACtC,MAAM,CAAC,GAAG,CAAC+C,aAAa,CAACT,MAAM,CAACtC,MAAM,CAAC,IAAI,CAAC,IAAIsC,MAAM,CAACJ,OAAO;EACrF,CAAC,CAAC;EAEF,OAAO;IACLxC,OAAO,EAAEgE,UAAU,CAACU,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAK;MACjC,IAAID,CAAC,CAACrE,MAAM,KAAKsE,CAAC,CAACtE,MAAM,EAAE,OAAOqE,CAAC,CAACrE,MAAM,CAACuE,aAAa,CAACD,CAAC,CAACtE,MAAM,CAAC;MAClE,IAAIqE,CAAC,CAAC9B,YAAY,KAAK+B,CAAC,CAAC/B,YAAY,EAAE,OAAO8B,CAAC,CAAC9B,YAAY,CAACgC,aAAa,CAACD,CAAC,CAAC/B,YAAY,CAAC;MAC1F,OAAO8B,CAAC,CAAC5C,WAAW,CAAC8C,aAAa,CAACD,CAAC,CAAC7C,WAAW,CAAC;IACnD,CAAC,CAAC;IACFwB,QAAQ,EAAE;MACRtD,QAAQ,EAAE,QAAQ;MAClBuD,OAAO,EAAEE,KAAK,CAACC,IAAI,CAACQ,UAAU,CAAC,CAACO,IAAI,CAAC,CAAC;MACtCjB,SAAS,EAAEC,KAAK,CAACC,IAAI,CAACM,YAAY,CAAC,CAACS,IAAI,CAAC,CAAC;MAC1Cb,QAAQ,EAAEH,KAAK,CAACC,IAAI,CAACO,WAAW,CAAC,CAACQ,IAAI,CAAC,CAAC;MACxCzB,YAAY;MACZG,UAAU;MACVC;IACF;EACF,CAAC;AACH;;AAEA;AACA;AACA;;AAkBA,OAAO,SAASyB,uBAAuBA,CACrC9E,OAA4B,EAC5B6C,YAAoB,EACM;EAC1B,MAAMkC,eAAe,GAAG/E,OAAO,CAACgF,MAAM,CAACC,CAAC,IAAIA,CAAC,CAACpC,YAAY,KAAKA,YAAY,CAAC;;EAE5E;EACA,MAAMqC,UAA+C,GAAG,CAAC,CAAC;EAC1DH,eAAe,CAACzB,OAAO,CAACV,MAAM,IAAI;IAChC,IAAI,CAACsC,UAAU,CAACtC,MAAM,CAACtC,MAAM,CAAC,EAAE;MAC9B4E,UAAU,CAACtC,MAAM,CAACtC,MAAM,CAAC,GAAG,EAAE;IAChC;IACA4E,UAAU,CAACtC,MAAM,CAACtC,MAAM,CAAC,CAACoB,IAAI,CAACkB,MAAM,CAAC;EACxC,CAAC,CAAC;EAEF,MAAMY,OAAO,GAAG2B,MAAM,CAACC,OAAO,CAACF,UAAU,CAAC,CACvCR,IAAI,CAAC,CAAC,CAACC,CAAC,CAAC,EAAE,CAACC,CAAC,CAAC,KAAKD,CAAC,CAACE,aAAa,CAACD,CAAC,CAAC,CAAC,CACtCS,GAAG,CAAC,CAAC,CAAC/E,MAAM,EAAEN,OAAO,CAAC,KAAK;IAC1B,MAAMsF,cAAsC,GAAG,CAAC,CAAC;IACjD,MAAMC,YAAoC,GAAG,CAAC,CAAC;IAE/CvF,OAAO,CAACsD,OAAO,CAACV,MAAM,IAAI;MACxB0C,cAAc,CAAC1C,MAAM,CAACb,WAAW,CAAC,GAAG,CAACuD,cAAc,CAAC1C,MAAM,CAACb,WAAW,CAAC,IAAI,CAAC,IAAIa,MAAM,CAACJ,OAAO;MAC/F+C,YAAY,CAAC3C,MAAM,CAACb,WAAW,CAAC,GAAG,CAACwD,YAAY,CAAC3C,MAAM,CAACb,WAAW,CAAC,IAAI,CAAC,IAAIa,MAAM,CAACR,KAAK;IAC3F,CAAC,CAAC;IAEF,MAAMoD,WAAW,GAAGL,MAAM,CAACC,OAAO,CAACE,cAAc,CAAC,CAC/CZ,IAAI,CAAC,CAAC,GAAEC,CAAC,CAAC,EAAE,GAAEC,CAAC,CAAC,KAAKA,CAAC,GAAGD,CAAC,CAAC,CAC3B3C,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CACXqD,GAAG,CAAC,CAAC,CAACtD,WAAW,EAAES,OAAO,CAAC,MAAM;MAChCT,WAAW;MACXS,OAAO;MACPJ,KAAK,EAAEmD,YAAY,CAACxD,WAAW;IACjC,CAAC,CAAC,CAAC;IAEL,OAAO;MACLzB,MAAM;MACN2C,YAAY,EAAEjD,OAAO,CAACkD,MAAM,CAAC,CAACC,GAAG,EAAE8B,CAAC,KAAK9B,GAAG,GAAG8B,CAAC,CAACzC,OAAO,EAAE,CAAC,CAAC;MAC5DY,UAAU,EAAEpD,OAAO,CAACkD,MAAM,CAAC,CAACC,GAAG,EAAE8B,CAAC,KAAK9B,GAAG,GAAG8B,CAAC,CAAC7C,KAAK,EAAE,CAAC,CAAC;MACxDqD,YAAY,EAAEN,MAAM,CAACO,IAAI,CAACJ,cAAc,CAAC,CAAC9E,MAAM;MAChDgF;IACF,CAAC;EACH,CAAC,CAAC;;EAEJ;EACA,IAAIG,YAA4D,GAAG,QAAQ;EAC3E,IAAIC,SAAyD,GAAG,QAAQ;EACxE,IAAIC,YAA4D,GAAG,QAAQ;EAE3E,IAAIrC,OAAO,CAAChD,MAAM,KAAK,CAAC,EAAE;IACxBmF,YAAY,GAAG,KAAK;IACpBC,SAAS,GAAG,KAAK;IACjBC,YAAY,GAAG,KAAK;EACtB,CAAC,MAAM,IAAIrC,OAAO,CAAChD,MAAM,IAAI,CAAC,EAAE;IAC9B,MAAMsF,MAAM,GAAGtC,OAAO,CAACA,OAAO,CAAChD,MAAM,GAAG,CAAC,CAAC;IAC1C,MAAMuF,QAAQ,GAAGvC,OAAO,CAACA,OAAO,CAAChD,MAAM,GAAG,CAAC,CAAC;IAE5C,MAAMwF,aAAa,GAAG,CAACF,MAAM,CAAC7C,YAAY,GAAG8C,QAAQ,CAAC9C,YAAY,IAAI8C,QAAQ,CAAC9C,YAAY;IAC3F,MAAMgD,UAAU,GAAG,CAACH,MAAM,CAAC1C,UAAU,GAAG2C,QAAQ,CAAC3C,UAAU,IAAI2C,QAAQ,CAAC3C,UAAU;IAClF,MAAM8C,aAAa,GAAGJ,MAAM,CAACL,YAAY,GAAGM,QAAQ,CAACN,YAAY;IAEjEE,YAAY,GAAGK,aAAa,GAAG,GAAG,GAAG,YAAY,GAAIA,aAAa,GAAG,CAAC,GAAG,GAAG,YAAY,GAAG,QAAS;IACpGJ,SAAS,GAAGK,UAAU,GAAG,GAAG,GAAG,YAAY,GAAIA,UAAU,GAAG,CAAC,GAAG,GAAG,YAAY,GAAG,QAAS;IAC3FJ,YAAY,GAAGK,aAAa,GAAG,CAAC,GAAG,WAAW,GAAIA,aAAa,GAAG,CAAC,GAAG,aAAa,GAAG,QAAS;EACjG;EAEA,IAAIC,MAAoD,GAAG,QAAQ;EACnE,IAAI3C,OAAO,CAAChD,MAAM,KAAK,CAAC,EAAE;IACxB2F,MAAM,GAAG,MAAM;EACjB,CAAC,MAAM,IAAI3C,OAAO,CAAChD,MAAM,KAAK,CAAC,IAAImF,YAAY,KAAK,KAAK,EAAE;IACzDQ,MAAM,GAAG,UAAU;EACrB,CAAC,MAAM,IAAIR,YAAY,KAAK,YAAY,IAAIC,SAAS,KAAK,YAAY,EAAE;IACtEO,MAAM,GAAG,WAAW;EACtB,CAAC,MAAM,IAAIR,YAAY,KAAK,YAAY,IAAIC,SAAS,KAAK,YAAY,EAAE;IACtEO,MAAM,GAAG,QAAQ;EACnB;EAEA,OAAO;IACLtD,YAAY;IACZW,OAAO;IACP4C,MAAM,EAAE;MACNT,YAAY;MACZC,SAAS;MACTC,YAAY;MACZM;IACF;EACF,CAAC;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}