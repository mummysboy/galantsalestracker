{"ast":null,"code":"/**\n * Parse CSV data and convert to invoice records\n * @param csvContent Raw CSV content as string\n * @param options Configuration options for parsing\n * @returns Parsed data with metadata\n */\nexport function parseInvoiceCSV(csvContent, options) {\n  const {\n    columnMappings,\n    defaultDate = new Date().toISOString().split('T')[0],\n    currencySymbol = '$',\n    delimiter = ','\n  } = options;\n  const lines = csvContent.trim().split('\\n');\n  const errors = [];\n  const records = [];\n  if (lines.length < 2) {\n    errors.push({\n      row: 0,\n      column: 'file',\n      value: 'CSV',\n      message: 'CSV file must have at least a header row and one data row'\n    });\n    return {\n      data: {\n        records: [],\n        metadata: createEmptyMetadata()\n      },\n      errors\n    };\n  }\n\n  // Parse header row\n  const headers = parseCSVLine(lines[0], delimiter);\n  const customerIndex = headers.findIndex(h => h.toLowerCase().includes(columnMappings.customerColumn.toLowerCase()) || h.toLowerCase().includes('customer') || h.toLowerCase().includes('client'));\n  const productIndex = headers.findIndex(h => h.toLowerCase().includes(columnMappings.productColumn.toLowerCase()) || h.toLowerCase().includes('product') || h.toLowerCase().includes('item'));\n  const quantityIndex = headers.findIndex(h => h.toLowerCase().includes(columnMappings.quantityColumn.toLowerCase()) || h.toLowerCase().includes('quantity') || h.toLowerCase().includes('qty') || h.toLowerCase().includes('cases'));\n  const revenueIndex = headers.findIndex(h => h.toLowerCase().includes(columnMappings.revenueColumn.toLowerCase()) || h.toLowerCase().includes('revenue') || h.toLowerCase().includes('amount') || h.toLowerCase().includes('value') || h.toLowerCase().includes('total'));\n  const dateIndex = columnMappings.dateColumn ? headers.findIndex(h => h.toLowerCase().includes(columnMappings.dateColumn.toLowerCase()) || h.toLowerCase().includes('date') || h.toLowerCase().includes('invoice')) : -1;\n\n  // Validate required columns\n  if (customerIndex === -1) {\n    errors.push({\n      row: 1,\n      column: 'header',\n      value: 'Customer column',\n      message: 'Could not find customer column. Please ensure column names contain \"customer\", \"client\", or match your specified mapping.'\n    });\n  }\n  if (productIndex === -1) {\n    errors.push({\n      row: 1,\n      column: 'header',\n      value: 'Product column',\n      message: 'Could not find product column. Please ensure column names contain \"product\", \"item\", or match your specified mapping.'\n    });\n  }\n  if (quantityIndex === -1) {\n    errors.push({\n      row: 1,\n      column: 'header',\n      value: 'Quantity column',\n      message: 'Could not find quantity column. Please ensure column names contain \"quantity\", \"qty\", \"cases\", or match your specified mapping.'\n    });\n  }\n  if (revenueIndex === -1) {\n    errors.push({\n      row: 1,\n      column: 'header',\n      value: 'Revenue column',\n      message: 'Could not find revenue column. Please ensure column names contain \"revenue\", \"amount\", \"value\", \"total\", or match your specified mapping.'\n    });\n  }\n  if (errors.length > 0) {\n    return {\n      data: {\n        records: [],\n        metadata: createEmptyMetadata()\n      },\n      errors\n    };\n  }\n\n  // Parse data rows\n  for (let i = 1; i < lines.length; i++) {\n    const row = lines[i].trim();\n    if (!row) continue; // Skip empty rows\n\n    try {\n      const columns = parseCSVLine(row, delimiter);\n\n      // Extract values\n      const customerName = cleanString(columns[customerIndex]);\n      const productName = cleanString(columns[productIndex]);\n      const quantityStr = columns[quantityIndex];\n      const revenueStr = columns[revenueIndex];\n      const dateStr = dateIndex >= 0 ? columns[dateIndex] : defaultDate;\n\n      // Validate and parse quantity\n      if (!customerName) {\n        errors.push({\n          row: i + 1,\n          column: headers[customerIndex],\n          value: customerName,\n          message: 'Customer name is required'\n        });\n        continue;\n      }\n      if (!productName) {\n        errors.push({\n          row: i + 1,\n          column: headers[productIndex],\n          value: productName,\n          message: 'Product name is required'\n        });\n        continue;\n      }\n      const quantity = parseNumericValue(quantityStr);\n      if (quantity === null || quantity < 0) {\n        errors.push({\n          row: i + 1,\n          column: headers[quantityIndex],\n          value: quantityStr || '',\n          message: 'Quantity must be a valid positive number'\n        });\n        continue;\n      }\n      const revenue = parseCurrencyValue(revenueStr, currencySymbol);\n      if (revenue === null || revenue < 0) {\n        errors.push({\n          row: i + 1,\n          column: headers[revenueIndex],\n          value: revenueStr || '',\n          message: 'Revenue must be a valid positive currency amount'\n        });\n        continue;\n      }\n      const date = parseDate(dateStr);\n      if (!date) {\n        errors.push({\n          row: i + 1,\n          column: headers[dateIndex] || 'Date',\n          value: dateStr || '',\n          message: 'Date must be in a valid format (YYYY-MM-DD, MM/DD/YYYY, etc.)'\n        });\n        continue;\n      }\n      records.push({\n        customerName,\n        productName,\n        quantity,\n        revenue,\n        date\n      });\n    } catch (error) {\n      errors.push({\n        row: i + 1,\n        column: 'general',\n        value: row.substring(0, 50) + '...',\n        message: `Error parsing row: ${error instanceof Error ? error.message : 'Unknown error'}`\n      });\n    }\n  }\n\n  // Generate metadata\n  const metadata = generateMetadata(records);\n  return {\n    data: {\n      records,\n      metadata\n    },\n    errors\n  };\n}\n\n/**\n * Parse BiRite-specific CSV format from your sample data\n */\nexport function parseBiRiteCSV(csvContent) {\n  const lines = csvContent.trim().split('\\n');\n  const errors = [];\n  const records = [];\n\n  // Skip the first few summary rows and find the actual data\n  let dataStartIndex = -1;\n  for (let i = 0; i < lines.length; i++) {\n    if (lines[i].includes('SUM of') || lines[i].includes('Customer')) {\n      dataStartIndex = i + 1;\n      break;\n    }\n  }\n  if (dataStartIndex === -1) {\n    errors.push({\n      row: 0,\n      column: 'file',\n      value: 'BiRite CSV',\n      message: 'Could not find data section in BiRite CSV format'\n    });\n    return {\n      data: {\n        records: [],\n        metadata: createEmptyMetadata()\n      },\n      errors\n    };\n  }\n\n  // Process data rows\n  for (let i = dataStartIndex; i < lines.length; i++) {\n    const line = lines[i].trim();\n    if (!line || line.includes('Total') || line === ',') continue;\n    const columns = line.split(',');\n    if (columns.length < 5) continue;\n    const customerName = columns[0].trim().replace(/^\"|\"$/g, '');\n    const productName = columns[1].trim().replace(/^\"|\"$/g, '');\n\n    // Skip if no customer or product\n    if (!customerName || !productName) continue;\n\n    // Parse quarterly data (Q1, Q2, Q3)\n    const quarters = [{\n      quarter: 'Q1',\n      months: ['01', '02', '03'],\n      date: '2024-03-15'\n    }, {\n      quarter: 'Q2',\n      months: ['04', '05', '06'],\n      date: '2024-06-15'\n    }, {\n      quarter: 'Q3',\n      months: ['07', '08', '09'],\n      date: '2024-09-15'\n    }];\n    for (let q = 0; q < quarters.length; q++) {\n      var _columns;\n      const qtyStr = (_columns = columns[q + 2]) === null || _columns === void 0 ? void 0 : _columns.trim();\n      if (!qtyStr || qtyStr === '') continue;\n      const quantity = parseInt(qtyStr);\n      if (isNaN(quantity) || quantity <= 0) continue;\n\n      // Estimate revenue based on typical beverage pricing ($4.50-$4.75)\n      const revenue = quantity * 4.50;\n      records.push({\n        customerName,\n        productName,\n        quantity,\n        revenue: Math.round(revenue * 100) / 100,\n        date: quarters[q].date\n      });\n    }\n  }\n  const metadata = generateMetadata(records);\n  return {\n    data: {\n      records,\n      metadata\n    },\n    errors\n  };\n}\n\n// Helper functions\n\nfunction parseCSVLine(line, delimiter) {\n  const result = [];\n  let current = '';\n  let inQuotes = false;\n  for (let i = 0; i < line.length; i++) {\n    const char = line[i];\n    if (char === '\"') {\n      if (inQuotes && line[i + 1] === '\"') {\n        current += '\"';\n        i++; // Skip next quote\n      } else {\n        inQuotes = !inQuotes;\n      }\n    } else if (char === delimiter && !inQuotes) {\n      result.push(current);\n      current = '';\n    } else {\n      current += char;\n    }\n  }\n  result.push(current);\n  return result;\n}\nfunction cleanString(str) {\n  return str.trim().replace(/^\"|\"$/g, '');\n}\nfunction parseNumericValue(str) {\n  if (!str) return null;\n  const cleaned = str.replace(/[,\\s]/g, '');\n  const num = parseFloat(cleaned);\n  return isNaN(num) ? null : num;\n}\nfunction parseCurrencyValue(str, currencySymbol) {\n  if (!str) return null;\n  const cleaned = str.replace(/[,\\s]/g, '').replace(currencySymbol, '');\n  const num = parseFloat(cleaned);\n  return isNaN(num) ? null : num;\n}\nfunction parseDate(str) {\n  if (!str) return null;\n\n  // Try different date formats\n  const formats = [/^\\d{4}-\\d{2}-\\d{2}$/,\n  // YYYY-MM-DD\n  /^\\d{2}\\/\\d{2}\\/\\d{4}$/,\n  // MM/DD/YYYY\n  /^\\d{4}\\/\\d{2}\\/\\d{2}$/,\n  // YYYY/MM/DD\n  /^\\d{2}-\\d{2}-\\d{4}$/ // MM-DD-YYYY\n  ];\n  const cleanDate = str.trim().replace(/\"/g, '');\n\n  // Check if it's already in YYYY-MM-DD format\n  if (formats[0].test(cleanDate)) {\n    return cleanDate;\n  }\n\n  // Try to parse other formats\n  const date = new Date(cleanDate);\n  if (!isNaN(date.getTime())) {\n    return date.toISOString().split('T')[0];\n  }\n  return null;\n}\nfunction generateMetadata(records) {\n  if (records.length === 0) {\n    return createEmptyMetadata();\n  }\n  const customers = new Set(records.map(r => r.customerName));\n  const products = new Set(records.map(r => r.productName));\n  const dates = records.map(r => r.date).filter(d => d);\n  const totalRevenue = records.reduce((sum, r) => sum + r.revenue, 0);\n  const totalQuantity = records.reduce((sum, r) => sum + r.quantity, 0);\n  return {\n    totalRecords: records.length,\n    uniqueCustomers: customers.size,\n    uniqueProducts: products.size,\n    dateRange: {\n      earliest: dates.length > 0 ? dates.sort()[0] : null,\n      latest: dates.length > 0 ? dates.sort().reverse()[0] : null\n    },\n    totalRevenue: Math.round(totalRevenue * 100) / 100,\n    totalQuantity\n  };\n}\nfunction createEmptyMetadata() {\n  return {\n    totalRecords: 0,\n    uniqueCustomers: 0,\n    uniqueProducts: 0,\n    dateRange: {\n      earliest: null,\n      latest: null\n    },\n    totalRevenue: 0,\n    totalQuantity: 0\n  };\n}","map":{"version":3,"names":["parseInvoiceCSV","csvContent","options","columnMappings","defaultDate","Date","toISOString","split","currencySymbol","delimiter","lines","trim","errors","records","length","push","row","column","value","message","data","metadata","createEmptyMetadata","headers","parseCSVLine","customerIndex","findIndex","h","toLowerCase","includes","customerColumn","productIndex","productColumn","quantityIndex","quantityColumn","revenueIndex","revenueColumn","dateIndex","dateColumn","i","columns","customerName","cleanString","productName","quantityStr","revenueStr","dateStr","quantity","parseNumericValue","revenue","parseCurrencyValue","date","parseDate","error","substring","Error","generateMetadata","parseBiRiteCSV","dataStartIndex","line","replace","quarters","quarter","months","q","_columns","qtyStr","parseInt","isNaN","Math","round","result","current","inQuotes","char","str","cleaned","num","parseFloat","formats","cleanDate","test","getTime","customers","Set","map","r","products","dates","filter","d","totalRevenue","reduce","sum","totalQuantity","totalRecords","uniqueCustomers","size","uniqueProducts","dateRange","earliest","sort","latest","reverse"],"sources":["/Users/isaachirsch/Desktop/GalantCo/SalesTracker/src/utils/csvParser.ts"],"sourcesContent":["export interface InvoiceRecord {\n  customerName: string;\n  productName: string;\n  quantity: number;\n  revenue: number;\n  date: string;\n}\n\nexport interface ParsedCSVData {\n  records: InvoiceRecord[];\n  metadata: {\n    totalRecords: number;\n    uniqueCustomers: number;\n    uniqueProducts: number;\n    dateRange: {\n      earliest: string | null;\n      latest: string | null;\n    };\n    totalRevenue: number;\n    totalQuantity: number;\n  };\n}\n\nexport interface CSVParseError {\n  row: number;\n  column: string;\n  value: string;\n  message: string;\n}\n\n/**\n * Parse CSV data and convert to invoice records\n * @param csvContent Raw CSV content as string\n * @param options Configuration options for parsing\n * @returns Parsed data with metadata\n */\nexport function parseInvoiceCSV(\n  csvContent: string,\n  options: {\n    columnMappings: {\n      customerColumn: string;\n      productColumn: string;\n      quantityColumn: string;\n      revenueColumn: string;\n      dateColumn?: string;\n    };\n    defaultDate?: string;\n    currencySymbol?: string;\n    delimiter?: string;\n  }\n): { data: ParsedCSVData; errors: CSVParseError[] } {\n  const {\n    columnMappings,\n    defaultDate = new Date().toISOString().split('T')[0],\n    currencySymbol = '$',\n    delimiter = ','\n  } = options;\n\n  const lines = csvContent.trim().split('\\n');\n  const errors: CSVParseError[] = [];\n  const records: InvoiceRecord[] = [];\n\n  if (lines.length < 2) {\n    errors.push({\n      row: 0,\n      column: 'file',\n      value: 'CSV',\n      message: 'CSV file must have at least a header row and one data row'\n    });\n    return { data: { records: [], metadata: createEmptyMetadata() }, errors };\n  }\n\n  // Parse header row\n  const headers = parseCSVLine(lines[0], delimiter);\n  const customerIndex = headers.findIndex(h => \n    h.toLowerCase().includes(columnMappings.customerColumn.toLowerCase()) ||\n    h.toLowerCase().includes('customer') ||\n    h.toLowerCase().includes('client')\n  );\n  const productIndex = headers.findIndex(h => \n    h.toLowerCase().includes(columnMappings.productColumn.toLowerCase()) ||\n    h.toLowerCase().includes('product') ||\n    h.toLowerCase().includes('item')\n  );\n  const quantityIndex = headers.findIndex(h => \n    h.toLowerCase().includes(columnMappings.quantityColumn.toLowerCase()) ||\n    h.toLowerCase().includes('quantity') ||\n    h.toLowerCase().includes('qty') ||\n    h.toLowerCase().includes('cases')\n  );\n  const revenueIndex = headers.findIndex(h => \n    h.toLowerCase().includes(columnMappings.revenueColumn.toLowerCase()) ||\n    h.toLowerCase().includes('revenue') ||\n    h.toLowerCase().includes('amount') ||\n    h.toLowerCase().includes('value') ||\n    h.toLowerCase().includes('total')\n  );\n  const dateIndex = columnMappings.dateColumn ? headers.findIndex(h => \n    h.toLowerCase().includes(columnMappings.dateColumn.toLowerCase()) ||\n    h.toLowerCase().includes('date') ||\n    h.toLowerCase().includes('invoice')\n  ) : -1;\n\n  // Validate required columns\n  if (customerIndex === -1) {\n    errors.push({\n      row: 1,\n      column: 'header',\n      value: 'Customer column',\n      message: 'Could not find customer column. Please ensure column names contain \"customer\", \"client\", or match your specified mapping.'\n    });\n  }\n  if (productIndex === -1) {\n    errors.push({\n      row: 1,\n      column: 'header',\n      value: 'Product column',\n      message: 'Could not find product column. Please ensure column names contain \"product\", \"item\", or match your specified mapping.'\n    });\n  }\n  if (quantityIndex === -1) {\n    errors.push({\n      row: 1,\n      column: 'header',\n      value: 'Quantity column',\n      message: 'Could not find quantity column. Please ensure column names contain \"quantity\", \"qty\", \"cases\", or match your specified mapping.'\n    });\n  }\n  if (revenueIndex === -1) {\n    errors.push({\n      row: 1,\n      column: 'header',\n      value: 'Revenue column',\n      message: 'Could not find revenue column. Please ensure column names contain \"revenue\", \"amount\", \"value\", \"total\", or match your specified mapping.'\n    });\n  }\n\n  if (errors.length > 0) {\n    return { data: { records: [], metadata: createEmptyMetadata() }, errors };\n  }\n\n  // Parse data rows\n  for (let i = 1; i < lines.length; i++) {\n    const row = lines[i].trim();\n    if (!row) continue; // Skip empty rows\n\n    try {\n      const columns = parseCSVLine(row, delimiter);\n      \n      // Extract values\n      const customerName = cleanString(columns[customerIndex]);\n      const productName = cleanString(columns[productIndex]);\n      const quantityStr = columns[quantityIndex];\n      const revenueStr = columns[revenueIndex];\n      const dateStr = dateIndex >= 0 ? columns[dateIndex] : defaultDate;\n\n      // Validate and parse quantity\n      if (!customerName) {\n        errors.push({\n          row: i + 1,\n          column: headers[customerIndex],\n          value: customerName,\n          message: 'Customer name is required'\n        });\n        continue;\n      }\n\n      if (!productName) {\n        errors.push({\n          row: i + 1,\n          column: headers[productIndex],\n          value: productName,\n          message: 'Product name is required'\n        });\n        continue;\n      }\n\n      const quantity = parseNumericValue(quantityStr);\n      if (quantity === null || quantity < 0) {\n        errors.push({\n          row: i + 1,\n          column: headers[quantityIndex],\n          value: quantityStr || '',\n          message: 'Quantity must be a valid positive number'\n        });\n        continue;\n      }\n\n      const revenue = parseCurrencyValue(revenueStr, currencySymbol);\n      if (revenue === null || revenue < 0) {\n        errors.push({\n          row: i + 1,\n          column: headers[revenueIndex],\n          value: revenueStr || '',\n          message: 'Revenue must be a valid positive currency amount'\n        });\n        continue;\n      }\n\n      const date = parseDate(dateStr);\n      if (!date) {\n        errors.push({\n          row: i + 1,\n          column: headers[dateIndex] || 'Date',\n          value: dateStr || '',\n          message: 'Date must be in a valid format (YYYY-MM-DD, MM/DD/YYYY, etc.)'\n        });\n        continue;\n      }\n\n      records.push({\n        customerName,\n        productName,\n        quantity,\n        revenue,\n        date\n      });\n\n    } catch (error) {\n      errors.push({\n        row: i + 1,\n        column: 'general',\n        value: row.substring(0, 50) + '...',\n        message: `Error parsing row: ${error instanceof Error ? error.message : 'Unknown error'}`\n      });\n    }\n  }\n\n  // Generate metadata\n  const metadata = generateMetadata(records);\n\n  return { data: { records, metadata }, errors };\n}\n\n/**\n * Parse BiRite-specific CSV format from your sample data\n */\nexport function parseBiRiteCSV(csvContent: string): { data: ParsedCSVData; errors: CSVParseError[] } {\n  const lines = csvContent.trim().split('\\n');\n  const errors: CSVParseError[] = [];\n  const records: InvoiceRecord[] = [];\n\n  // Skip the first few summary rows and find the actual data\n  let dataStartIndex = -1;\n  for (let i = 0; i < lines.length; i++) {\n    if (lines[i].includes('SUM of') || lines[i].includes('Customer')) {\n      dataStartIndex = i + 1;\n      break;\n    }\n  }\n\n  if (dataStartIndex === -1) {\n    errors.push({\n      row: 0,\n      column: 'file',\n      value: 'BiRite CSV',\n      message: 'Could not find data section in BiRite CSV format'\n    });\n    return { data: { records: [], metadata: createEmptyMetadata() }, errors };\n  }\n\n  // Process data rows\n  for (let i = dataStartIndex; i < lines.length; i++) {\n    const line = lines[i].trim();\n    if (!line || line.includes('Total') || line === ',') continue;\n\n    const columns = line.split(',');\n    if (columns.length < 5) continue;\n\n    const customerName = columns[0].trim().replace(/^\"|\"$/g, '');\n    const productName = columns[1].trim().replace(/^\"|\"$/g, '');\n\n    // Skip if no customer or product\n    if (!customerName || !productName) continue;\n\n    // Parse quarterly data (Q1, Q2, Q3)\n    const quarters = [\n      { quarter: 'Q1', months: ['01', '02', '03'], date: '2024-03-15' },\n      { quarter: 'Q2', months: ['04', '05', '06'], date: '2024-06-15' },\n      { quarter: 'Q3', months: ['07', '08', '09'], date: '2024-09-15' }\n    ];\n\n    for (let q = 0; q < quarters.length; q++) {\n      const qtyStr = columns[q + 2]?.trim();\n      if (!qtyStr || qtyStr === '') continue;\n\n      const quantity = parseInt(qtyStr);\n      if (isNaN(quantity) || quantity <= 0) continue;\n\n      // Estimate revenue based on typical beverage pricing ($4.50-$4.75)\n      const revenue = quantity * 4.50;\n\n      records.push({\n        customerName,\n        productName,\n        quantity,\n        revenue: Math.round(revenue * 100) / 100,\n        date: quarters[q].date\n      });\n    }\n  }\n\n  const metadata = generateMetadata(records);\n  return { data: { records, metadata }, errors };\n}\n\n// Helper functions\n\nfunction parseCSVLine(line: string, delimiter: string): string[] {\n  const result: string[] = [];\n  let current = '';\n  let inQuotes = false;\n  \n  for (let i = 0; i < line.length; i++) {\n    const char = line[i];\n    \n    if (char === '\"') {\n      if (inQuotes && line[i + 1] === '\"') {\n        current += '\"';\n        i++; // Skip next quote\n      } else {\n        inQuotes = !inQuotes;\n      }\n    } else if (char === delimiter && !inQuotes) {\n      result.push(current);\n      current = '';\n    } else {\n      current += char;\n    }\n  }\n  \n  result.push(current);\n  return result;\n}\n\nfunction cleanString(str: string): string {\n  return str.trim().replace(/^\"|\"$/g, '');\n}\n\nfunction parseNumericValue(str: string): number | null {\n  if (!str) return null;\n  const cleaned = str.replace(/[,\\s]/g, '');\n  const num = parseFloat(cleaned);\n  return isNaN(num) ? null : num;\n}\n\nfunction parseCurrencyValue(str: string, currencySymbol: string): number | null {\n  if (!str) return null;\n  const cleaned = str.replace(/[,\\s]/g, '').replace(currencySymbol, '');\n  const num = parseFloat(cleaned);\n  return isNaN(num) ? null : num;\n}\n\nfunction parseDate(str: string): string | null {\n  if (!str) return null;\n  \n  // Try different date formats\n  const formats = [\n    /^\\d{4}-\\d{2}-\\d{2}$/, // YYYY-MM-DD\n    /^\\d{2}\\/\\d{2}\\/\\d{4}$/, // MM/DD/YYYY\n    /^\\d{4}\\/\\d{2}\\/\\d{2}$/, // YYYY/MM/DD\n    /^\\d{2}-\\d{2}-\\d{4}$/, // MM-DD-YYYY\n  ];\n\n  const cleanDate = str.trim().replace(/\"/g, '');\n  \n  // Check if it's already in YYYY-MM-DD format\n  if (formats[0].test(cleanDate)) {\n    return cleanDate;\n  }\n  \n  // Try to parse other formats\n  const date = new Date(cleanDate);\n  if (!isNaN(date.getTime())) {\n    return date.toISOString().split('T')[0];\n  }\n  \n  return null;\n}\n\nfunction generateMetadata(records: InvoiceRecord[]) {\n  if (records.length === 0) {\n    return createEmptyMetadata();\n  }\n\n  const customers = new Set(records.map(r => r.customerName));\n  const products = new Set(records.map(r => r.productName));\n  const dates = records.map(r => r.date).filter(d => d);\n  const totalRevenue = records.reduce((sum, r) => sum + r.revenue, 0);\n  const totalQuantity = records.reduce((sum, r) => sum + r.quantity, 0);\n\n  return {\n    totalRecords: records.length,\n    uniqueCustomers: customers.size,\n    uniqueProducts: products.size,\n    dateRange: {\n      earliest: dates.length > 0 ? dates.sort()[0] : null,\n      latest: dates.length > 0 ? dates.sort().reverse()[0] : null\n    },\n    totalRevenue: Math.round(totalRevenue * 100) / 100,\n    totalQuantity\n  };\n}\n\nfunction createEmptyMetadata() {\n  return {\n    totalRecords: 0,\n    uniqueCustomers: 0,\n    uniqueProducts: 0,\n    dateRange: { earliest: null, latest: null },\n    totalRevenue: 0,\n    totalQuantity: 0\n  };\n}\n"],"mappings":"AA8BA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,eAAeA,CAC7BC,UAAkB,EAClBC,OAWC,EACiD;EAClD,MAAM;IACJC,cAAc;IACdC,WAAW,GAAG,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,CAACC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;IACpDC,cAAc,GAAG,GAAG;IACpBC,SAAS,GAAG;EACd,CAAC,GAAGP,OAAO;EAEX,MAAMQ,KAAK,GAAGT,UAAU,CAACU,IAAI,CAAC,CAAC,CAACJ,KAAK,CAAC,IAAI,CAAC;EAC3C,MAAMK,MAAuB,GAAG,EAAE;EAClC,MAAMC,OAAwB,GAAG,EAAE;EAEnC,IAAIH,KAAK,CAACI,MAAM,GAAG,CAAC,EAAE;IACpBF,MAAM,CAACG,IAAI,CAAC;MACVC,GAAG,EAAE,CAAC;MACNC,MAAM,EAAE,MAAM;MACdC,KAAK,EAAE,KAAK;MACZC,OAAO,EAAE;IACX,CAAC,CAAC;IACF,OAAO;MAAEC,IAAI,EAAE;QAAEP,OAAO,EAAE,EAAE;QAAEQ,QAAQ,EAAEC,mBAAmB,CAAC;MAAE,CAAC;MAAEV;IAAO,CAAC;EAC3E;;EAEA;EACA,MAAMW,OAAO,GAAGC,YAAY,CAACd,KAAK,CAAC,CAAC,CAAC,EAAED,SAAS,CAAC;EACjD,MAAMgB,aAAa,GAAGF,OAAO,CAACG,SAAS,CAACC,CAAC,IACvCA,CAAC,CAACC,WAAW,CAAC,CAAC,CAACC,QAAQ,CAAC1B,cAAc,CAAC2B,cAAc,CAACF,WAAW,CAAC,CAAC,CAAC,IACrED,CAAC,CAACC,WAAW,CAAC,CAAC,CAACC,QAAQ,CAAC,UAAU,CAAC,IACpCF,CAAC,CAACC,WAAW,CAAC,CAAC,CAACC,QAAQ,CAAC,QAAQ,CACnC,CAAC;EACD,MAAME,YAAY,GAAGR,OAAO,CAACG,SAAS,CAACC,CAAC,IACtCA,CAAC,CAACC,WAAW,CAAC,CAAC,CAACC,QAAQ,CAAC1B,cAAc,CAAC6B,aAAa,CAACJ,WAAW,CAAC,CAAC,CAAC,IACpED,CAAC,CAACC,WAAW,CAAC,CAAC,CAACC,QAAQ,CAAC,SAAS,CAAC,IACnCF,CAAC,CAACC,WAAW,CAAC,CAAC,CAACC,QAAQ,CAAC,MAAM,CACjC,CAAC;EACD,MAAMI,aAAa,GAAGV,OAAO,CAACG,SAAS,CAACC,CAAC,IACvCA,CAAC,CAACC,WAAW,CAAC,CAAC,CAACC,QAAQ,CAAC1B,cAAc,CAAC+B,cAAc,CAACN,WAAW,CAAC,CAAC,CAAC,IACrED,CAAC,CAACC,WAAW,CAAC,CAAC,CAACC,QAAQ,CAAC,UAAU,CAAC,IACpCF,CAAC,CAACC,WAAW,CAAC,CAAC,CAACC,QAAQ,CAAC,KAAK,CAAC,IAC/BF,CAAC,CAACC,WAAW,CAAC,CAAC,CAACC,QAAQ,CAAC,OAAO,CAClC,CAAC;EACD,MAAMM,YAAY,GAAGZ,OAAO,CAACG,SAAS,CAACC,CAAC,IACtCA,CAAC,CAACC,WAAW,CAAC,CAAC,CAACC,QAAQ,CAAC1B,cAAc,CAACiC,aAAa,CAACR,WAAW,CAAC,CAAC,CAAC,IACpED,CAAC,CAACC,WAAW,CAAC,CAAC,CAACC,QAAQ,CAAC,SAAS,CAAC,IACnCF,CAAC,CAACC,WAAW,CAAC,CAAC,CAACC,QAAQ,CAAC,QAAQ,CAAC,IAClCF,CAAC,CAACC,WAAW,CAAC,CAAC,CAACC,QAAQ,CAAC,OAAO,CAAC,IACjCF,CAAC,CAACC,WAAW,CAAC,CAAC,CAACC,QAAQ,CAAC,OAAO,CAClC,CAAC;EACD,MAAMQ,SAAS,GAAGlC,cAAc,CAACmC,UAAU,GAAGf,OAAO,CAACG,SAAS,CAACC,CAAC,IAC/DA,CAAC,CAACC,WAAW,CAAC,CAAC,CAACC,QAAQ,CAAC1B,cAAc,CAACmC,UAAU,CAACV,WAAW,CAAC,CAAC,CAAC,IACjED,CAAC,CAACC,WAAW,CAAC,CAAC,CAACC,QAAQ,CAAC,MAAM,CAAC,IAChCF,CAAC,CAACC,WAAW,CAAC,CAAC,CAACC,QAAQ,CAAC,SAAS,CACpC,CAAC,GAAG,CAAC,CAAC;;EAEN;EACA,IAAIJ,aAAa,KAAK,CAAC,CAAC,EAAE;IACxBb,MAAM,CAACG,IAAI,CAAC;MACVC,GAAG,EAAE,CAAC;MACNC,MAAM,EAAE,QAAQ;MAChBC,KAAK,EAAE,iBAAiB;MACxBC,OAAO,EAAE;IACX,CAAC,CAAC;EACJ;EACA,IAAIY,YAAY,KAAK,CAAC,CAAC,EAAE;IACvBnB,MAAM,CAACG,IAAI,CAAC;MACVC,GAAG,EAAE,CAAC;MACNC,MAAM,EAAE,QAAQ;MAChBC,KAAK,EAAE,gBAAgB;MACvBC,OAAO,EAAE;IACX,CAAC,CAAC;EACJ;EACA,IAAIc,aAAa,KAAK,CAAC,CAAC,EAAE;IACxBrB,MAAM,CAACG,IAAI,CAAC;MACVC,GAAG,EAAE,CAAC;MACNC,MAAM,EAAE,QAAQ;MAChBC,KAAK,EAAE,iBAAiB;MACxBC,OAAO,EAAE;IACX,CAAC,CAAC;EACJ;EACA,IAAIgB,YAAY,KAAK,CAAC,CAAC,EAAE;IACvBvB,MAAM,CAACG,IAAI,CAAC;MACVC,GAAG,EAAE,CAAC;MACNC,MAAM,EAAE,QAAQ;MAChBC,KAAK,EAAE,gBAAgB;MACvBC,OAAO,EAAE;IACX,CAAC,CAAC;EACJ;EAEA,IAAIP,MAAM,CAACE,MAAM,GAAG,CAAC,EAAE;IACrB,OAAO;MAAEM,IAAI,EAAE;QAAEP,OAAO,EAAE,EAAE;QAAEQ,QAAQ,EAAEC,mBAAmB,CAAC;MAAE,CAAC;MAAEV;IAAO,CAAC;EAC3E;;EAEA;EACA,KAAK,IAAI2B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7B,KAAK,CAACI,MAAM,EAAEyB,CAAC,EAAE,EAAE;IACrC,MAAMvB,GAAG,GAAGN,KAAK,CAAC6B,CAAC,CAAC,CAAC5B,IAAI,CAAC,CAAC;IAC3B,IAAI,CAACK,GAAG,EAAE,SAAS,CAAC;;IAEpB,IAAI;MACF,MAAMwB,OAAO,GAAGhB,YAAY,CAACR,GAAG,EAAEP,SAAS,CAAC;;MAE5C;MACA,MAAMgC,YAAY,GAAGC,WAAW,CAACF,OAAO,CAACf,aAAa,CAAC,CAAC;MACxD,MAAMkB,WAAW,GAAGD,WAAW,CAACF,OAAO,CAACT,YAAY,CAAC,CAAC;MACtD,MAAMa,WAAW,GAAGJ,OAAO,CAACP,aAAa,CAAC;MAC1C,MAAMY,UAAU,GAAGL,OAAO,CAACL,YAAY,CAAC;MACxC,MAAMW,OAAO,GAAGT,SAAS,IAAI,CAAC,GAAGG,OAAO,CAACH,SAAS,CAAC,GAAGjC,WAAW;;MAEjE;MACA,IAAI,CAACqC,YAAY,EAAE;QACjB7B,MAAM,CAACG,IAAI,CAAC;UACVC,GAAG,EAAEuB,CAAC,GAAG,CAAC;UACVtB,MAAM,EAAEM,OAAO,CAACE,aAAa,CAAC;UAC9BP,KAAK,EAAEuB,YAAY;UACnBtB,OAAO,EAAE;QACX,CAAC,CAAC;QACF;MACF;MAEA,IAAI,CAACwB,WAAW,EAAE;QAChB/B,MAAM,CAACG,IAAI,CAAC;UACVC,GAAG,EAAEuB,CAAC,GAAG,CAAC;UACVtB,MAAM,EAAEM,OAAO,CAACQ,YAAY,CAAC;UAC7Bb,KAAK,EAAEyB,WAAW;UAClBxB,OAAO,EAAE;QACX,CAAC,CAAC;QACF;MACF;MAEA,MAAM4B,QAAQ,GAAGC,iBAAiB,CAACJ,WAAW,CAAC;MAC/C,IAAIG,QAAQ,KAAK,IAAI,IAAIA,QAAQ,GAAG,CAAC,EAAE;QACrCnC,MAAM,CAACG,IAAI,CAAC;UACVC,GAAG,EAAEuB,CAAC,GAAG,CAAC;UACVtB,MAAM,EAAEM,OAAO,CAACU,aAAa,CAAC;UAC9Bf,KAAK,EAAE0B,WAAW,IAAI,EAAE;UACxBzB,OAAO,EAAE;QACX,CAAC,CAAC;QACF;MACF;MAEA,MAAM8B,OAAO,GAAGC,kBAAkB,CAACL,UAAU,EAAErC,cAAc,CAAC;MAC9D,IAAIyC,OAAO,KAAK,IAAI,IAAIA,OAAO,GAAG,CAAC,EAAE;QACnCrC,MAAM,CAACG,IAAI,CAAC;UACVC,GAAG,EAAEuB,CAAC,GAAG,CAAC;UACVtB,MAAM,EAAEM,OAAO,CAACY,YAAY,CAAC;UAC7BjB,KAAK,EAAE2B,UAAU,IAAI,EAAE;UACvB1B,OAAO,EAAE;QACX,CAAC,CAAC;QACF;MACF;MAEA,MAAMgC,IAAI,GAAGC,SAAS,CAACN,OAAO,CAAC;MAC/B,IAAI,CAACK,IAAI,EAAE;QACTvC,MAAM,CAACG,IAAI,CAAC;UACVC,GAAG,EAAEuB,CAAC,GAAG,CAAC;UACVtB,MAAM,EAAEM,OAAO,CAACc,SAAS,CAAC,IAAI,MAAM;UACpCnB,KAAK,EAAE4B,OAAO,IAAI,EAAE;UACpB3B,OAAO,EAAE;QACX,CAAC,CAAC;QACF;MACF;MAEAN,OAAO,CAACE,IAAI,CAAC;QACX0B,YAAY;QACZE,WAAW;QACXI,QAAQ;QACRE,OAAO;QACPE;MACF,CAAC,CAAC;IAEJ,CAAC,CAAC,OAAOE,KAAK,EAAE;MACdzC,MAAM,CAACG,IAAI,CAAC;QACVC,GAAG,EAAEuB,CAAC,GAAG,CAAC;QACVtB,MAAM,EAAE,SAAS;QACjBC,KAAK,EAAEF,GAAG,CAACsC,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,KAAK;QACnCnC,OAAO,EAAE,sBAAsBkC,KAAK,YAAYE,KAAK,GAAGF,KAAK,CAAClC,OAAO,GAAG,eAAe;MACzF,CAAC,CAAC;IACJ;EACF;;EAEA;EACA,MAAME,QAAQ,GAAGmC,gBAAgB,CAAC3C,OAAO,CAAC;EAE1C,OAAO;IAAEO,IAAI,EAAE;MAAEP,OAAO;MAAEQ;IAAS,CAAC;IAAET;EAAO,CAAC;AAChD;;AAEA;AACA;AACA;AACA,OAAO,SAAS6C,cAAcA,CAACxD,UAAkB,EAAoD;EACnG,MAAMS,KAAK,GAAGT,UAAU,CAACU,IAAI,CAAC,CAAC,CAACJ,KAAK,CAAC,IAAI,CAAC;EAC3C,MAAMK,MAAuB,GAAG,EAAE;EAClC,MAAMC,OAAwB,GAAG,EAAE;;EAEnC;EACA,IAAI6C,cAAc,GAAG,CAAC,CAAC;EACvB,KAAK,IAAInB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7B,KAAK,CAACI,MAAM,EAAEyB,CAAC,EAAE,EAAE;IACrC,IAAI7B,KAAK,CAAC6B,CAAC,CAAC,CAACV,QAAQ,CAAC,QAAQ,CAAC,IAAInB,KAAK,CAAC6B,CAAC,CAAC,CAACV,QAAQ,CAAC,UAAU,CAAC,EAAE;MAChE6B,cAAc,GAAGnB,CAAC,GAAG,CAAC;MACtB;IACF;EACF;EAEA,IAAImB,cAAc,KAAK,CAAC,CAAC,EAAE;IACzB9C,MAAM,CAACG,IAAI,CAAC;MACVC,GAAG,EAAE,CAAC;MACNC,MAAM,EAAE,MAAM;MACdC,KAAK,EAAE,YAAY;MACnBC,OAAO,EAAE;IACX,CAAC,CAAC;IACF,OAAO;MAAEC,IAAI,EAAE;QAAEP,OAAO,EAAE,EAAE;QAAEQ,QAAQ,EAAEC,mBAAmB,CAAC;MAAE,CAAC;MAAEV;IAAO,CAAC;EAC3E;;EAEA;EACA,KAAK,IAAI2B,CAAC,GAAGmB,cAAc,EAAEnB,CAAC,GAAG7B,KAAK,CAACI,MAAM,EAAEyB,CAAC,EAAE,EAAE;IAClD,MAAMoB,IAAI,GAAGjD,KAAK,CAAC6B,CAAC,CAAC,CAAC5B,IAAI,CAAC,CAAC;IAC5B,IAAI,CAACgD,IAAI,IAAIA,IAAI,CAAC9B,QAAQ,CAAC,OAAO,CAAC,IAAI8B,IAAI,KAAK,GAAG,EAAE;IAErD,MAAMnB,OAAO,GAAGmB,IAAI,CAACpD,KAAK,CAAC,GAAG,CAAC;IAC/B,IAAIiC,OAAO,CAAC1B,MAAM,GAAG,CAAC,EAAE;IAExB,MAAM2B,YAAY,GAAGD,OAAO,CAAC,CAAC,CAAC,CAAC7B,IAAI,CAAC,CAAC,CAACiD,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC;IAC5D,MAAMjB,WAAW,GAAGH,OAAO,CAAC,CAAC,CAAC,CAAC7B,IAAI,CAAC,CAAC,CAACiD,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC;;IAE3D;IACA,IAAI,CAACnB,YAAY,IAAI,CAACE,WAAW,EAAE;;IAEnC;IACA,MAAMkB,QAAQ,GAAG,CACf;MAAEC,OAAO,EAAE,IAAI;MAAEC,MAAM,EAAE,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;MAAEZ,IAAI,EAAE;IAAa,CAAC,EACjE;MAAEW,OAAO,EAAE,IAAI;MAAEC,MAAM,EAAE,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;MAAEZ,IAAI,EAAE;IAAa,CAAC,EACjE;MAAEW,OAAO,EAAE,IAAI;MAAEC,MAAM,EAAE,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;MAAEZ,IAAI,EAAE;IAAa,CAAC,CAClE;IAED,KAAK,IAAIa,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,QAAQ,CAAC/C,MAAM,EAAEkD,CAAC,EAAE,EAAE;MAAA,IAAAC,QAAA;MACxC,MAAMC,MAAM,IAAAD,QAAA,GAAGzB,OAAO,CAACwB,CAAC,GAAG,CAAC,CAAC,cAAAC,QAAA,uBAAdA,QAAA,CAAgBtD,IAAI,CAAC,CAAC;MACrC,IAAI,CAACuD,MAAM,IAAIA,MAAM,KAAK,EAAE,EAAE;MAE9B,MAAMnB,QAAQ,GAAGoB,QAAQ,CAACD,MAAM,CAAC;MACjC,IAAIE,KAAK,CAACrB,QAAQ,CAAC,IAAIA,QAAQ,IAAI,CAAC,EAAE;;MAEtC;MACA,MAAME,OAAO,GAAGF,QAAQ,GAAG,IAAI;MAE/BlC,OAAO,CAACE,IAAI,CAAC;QACX0B,YAAY;QACZE,WAAW;QACXI,QAAQ;QACRE,OAAO,EAAEoB,IAAI,CAACC,KAAK,CAACrB,OAAO,GAAG,GAAG,CAAC,GAAG,GAAG;QACxCE,IAAI,EAAEU,QAAQ,CAACG,CAAC,CAAC,CAACb;MACpB,CAAC,CAAC;IACJ;EACF;EAEA,MAAM9B,QAAQ,GAAGmC,gBAAgB,CAAC3C,OAAO,CAAC;EAC1C,OAAO;IAAEO,IAAI,EAAE;MAAEP,OAAO;MAAEQ;IAAS,CAAC;IAAET;EAAO,CAAC;AAChD;;AAEA;;AAEA,SAASY,YAAYA,CAACmC,IAAY,EAAElD,SAAiB,EAAY;EAC/D,MAAM8D,MAAgB,GAAG,EAAE;EAC3B,IAAIC,OAAO,GAAG,EAAE;EAChB,IAAIC,QAAQ,GAAG,KAAK;EAEpB,KAAK,IAAIlC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoB,IAAI,CAAC7C,MAAM,EAAEyB,CAAC,EAAE,EAAE;IACpC,MAAMmC,IAAI,GAAGf,IAAI,CAACpB,CAAC,CAAC;IAEpB,IAAImC,IAAI,KAAK,GAAG,EAAE;MAChB,IAAID,QAAQ,IAAId,IAAI,CAACpB,CAAC,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;QACnCiC,OAAO,IAAI,GAAG;QACdjC,CAAC,EAAE,CAAC,CAAC;MACP,CAAC,MAAM;QACLkC,QAAQ,GAAG,CAACA,QAAQ;MACtB;IACF,CAAC,MAAM,IAAIC,IAAI,KAAKjE,SAAS,IAAI,CAACgE,QAAQ,EAAE;MAC1CF,MAAM,CAACxD,IAAI,CAACyD,OAAO,CAAC;MACpBA,OAAO,GAAG,EAAE;IACd,CAAC,MAAM;MACLA,OAAO,IAAIE,IAAI;IACjB;EACF;EAEAH,MAAM,CAACxD,IAAI,CAACyD,OAAO,CAAC;EACpB,OAAOD,MAAM;AACf;AAEA,SAAS7B,WAAWA,CAACiC,GAAW,EAAU;EACxC,OAAOA,GAAG,CAAChE,IAAI,CAAC,CAAC,CAACiD,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC;AACzC;AAEA,SAASZ,iBAAiBA,CAAC2B,GAAW,EAAiB;EACrD,IAAI,CAACA,GAAG,EAAE,OAAO,IAAI;EACrB,MAAMC,OAAO,GAAGD,GAAG,CAACf,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC;EACzC,MAAMiB,GAAG,GAAGC,UAAU,CAACF,OAAO,CAAC;EAC/B,OAAOR,KAAK,CAACS,GAAG,CAAC,GAAG,IAAI,GAAGA,GAAG;AAChC;AAEA,SAAS3B,kBAAkBA,CAACyB,GAAW,EAAEnE,cAAsB,EAAiB;EAC9E,IAAI,CAACmE,GAAG,EAAE,OAAO,IAAI;EACrB,MAAMC,OAAO,GAAGD,GAAG,CAACf,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAACA,OAAO,CAACpD,cAAc,EAAE,EAAE,CAAC;EACrE,MAAMqE,GAAG,GAAGC,UAAU,CAACF,OAAO,CAAC;EAC/B,OAAOR,KAAK,CAACS,GAAG,CAAC,GAAG,IAAI,GAAGA,GAAG;AAChC;AAEA,SAASzB,SAASA,CAACuB,GAAW,EAAiB;EAC7C,IAAI,CAACA,GAAG,EAAE,OAAO,IAAI;;EAErB;EACA,MAAMI,OAAO,GAAG,CACd,qBAAqB;EAAE;EACvB,uBAAuB;EAAE;EACzB,uBAAuB;EAAE;EACzB,qBAAqB,CAAE;EAAA,CACxB;EAED,MAAMC,SAAS,GAAGL,GAAG,CAAChE,IAAI,CAAC,CAAC,CAACiD,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC;;EAE9C;EACA,IAAImB,OAAO,CAAC,CAAC,CAAC,CAACE,IAAI,CAACD,SAAS,CAAC,EAAE;IAC9B,OAAOA,SAAS;EAClB;;EAEA;EACA,MAAM7B,IAAI,GAAG,IAAI9C,IAAI,CAAC2E,SAAS,CAAC;EAChC,IAAI,CAACZ,KAAK,CAACjB,IAAI,CAAC+B,OAAO,CAAC,CAAC,CAAC,EAAE;IAC1B,OAAO/B,IAAI,CAAC7C,WAAW,CAAC,CAAC,CAACC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;EACzC;EAEA,OAAO,IAAI;AACb;AAEA,SAASiD,gBAAgBA,CAAC3C,OAAwB,EAAE;EAClD,IAAIA,OAAO,CAACC,MAAM,KAAK,CAAC,EAAE;IACxB,OAAOQ,mBAAmB,CAAC,CAAC;EAC9B;EAEA,MAAM6D,SAAS,GAAG,IAAIC,GAAG,CAACvE,OAAO,CAACwE,GAAG,CAACC,CAAC,IAAIA,CAAC,CAAC7C,YAAY,CAAC,CAAC;EAC3D,MAAM8C,QAAQ,GAAG,IAAIH,GAAG,CAACvE,OAAO,CAACwE,GAAG,CAACC,CAAC,IAAIA,CAAC,CAAC3C,WAAW,CAAC,CAAC;EACzD,MAAM6C,KAAK,GAAG3E,OAAO,CAACwE,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACnC,IAAI,CAAC,CAACsC,MAAM,CAACC,CAAC,IAAIA,CAAC,CAAC;EACrD,MAAMC,YAAY,GAAG9E,OAAO,CAAC+E,MAAM,CAAC,CAACC,GAAG,EAAEP,CAAC,KAAKO,GAAG,GAAGP,CAAC,CAACrC,OAAO,EAAE,CAAC,CAAC;EACnE,MAAM6C,aAAa,GAAGjF,OAAO,CAAC+E,MAAM,CAAC,CAACC,GAAG,EAAEP,CAAC,KAAKO,GAAG,GAAGP,CAAC,CAACvC,QAAQ,EAAE,CAAC,CAAC;EAErE,OAAO;IACLgD,YAAY,EAAElF,OAAO,CAACC,MAAM;IAC5BkF,eAAe,EAAEb,SAAS,CAACc,IAAI;IAC/BC,cAAc,EAAEX,QAAQ,CAACU,IAAI;IAC7BE,SAAS,EAAE;MACTC,QAAQ,EAAEZ,KAAK,CAAC1E,MAAM,GAAG,CAAC,GAAG0E,KAAK,CAACa,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI;MACnDC,MAAM,EAAEd,KAAK,CAAC1E,MAAM,GAAG,CAAC,GAAG0E,KAAK,CAACa,IAAI,CAAC,CAAC,CAACE,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG;IACzD,CAAC;IACDZ,YAAY,EAAEtB,IAAI,CAACC,KAAK,CAACqB,YAAY,GAAG,GAAG,CAAC,GAAG,GAAG;IAClDG;EACF,CAAC;AACH;AAEA,SAASxE,mBAAmBA,CAAA,EAAG;EAC7B,OAAO;IACLyE,YAAY,EAAE,CAAC;IACfC,eAAe,EAAE,CAAC;IAClBE,cAAc,EAAE,CAAC;IACjBC,SAAS,EAAE;MAAEC,QAAQ,EAAE,IAAI;MAAEE,MAAM,EAAE;IAAK,CAAC;IAC3CX,YAAY,EAAE,CAAC;IACfG,aAAa,EAAE;EACjB,CAAC;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}