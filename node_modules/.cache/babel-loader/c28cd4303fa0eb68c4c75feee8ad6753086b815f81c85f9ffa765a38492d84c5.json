{"ast":null,"code":"/**\n * Parse Alpine TXT sales report files\n * @param txtContent Raw TXT content as string\n * @param reportDate Report date to identify the period (format: YYYY-MM)\n * @returns Parsed Alpine sales data\n */\nexport function parseAlpineTXT(txtContent, reportDate) {\n  const lines = txtContent.split('\\n');\n  const records = [];\n  const supplier = 'ALPINE';\n\n  // Look for period information in the header\n  const headerLine = lines.find(line => line.includes('FROM :') && line.includes('THRU'));\n  let period = reportDate;\n  if (headerLine) {\n    const match = headerLine.match(/(\\d{1,2}\\/\\d{1,2}\\/\\d{2,4})/g);\n    if (match && match.length >= 2) {\n      const [, toDate] = match;\n      const [month, day, year] = toDate.includes('/') ? toDate.split('/') : ['', '', ''];\n      if (month && year) {\n        // Convert to YYYY-MM format\n        const fullYear = year.length === 2 ? `20${year}` : year;\n        period = `${fullYear}-${month.padStart(2, '0')}`;\n      }\n    }\n  }\n\n  // Find customers and their purchases\n  let currentCustomer = '';\n  let currentCustomers = [];\n  let currentProducts = [];\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n\n    // Skip empty lines and headers\n    if (!line || line.startsWith('IT415V') || line.startsWith('SALES RECAP') || line.startsWith('FROM :') || line.startsWith('RUN DATE') || line.startsWith('GALANT GALANT') || line.startsWith('ALPINE') || line.startsWith('DESCRIPTION') || line.startsWith('-----------') || line === 'SALES' || line.includes('MFG ITEM #')) {\n      continue;\n    }\n\n    // Check if this is a customer line (starts with customer number and description)\n    const customerMatch = line.match(/^(\\d{6}-\\d{3})\\s+(.+)$/);\n    if (customerMatch) {\n      const [,, customerDescription] = customerMatch;\n      currentCustomer = customerDescription.trim();\n      currentCustomers.push(currentCustomer);\n      continue;\n    }\n\n    // Check if this is a product line (indented with spaces at the beginning)\n    const productMatch = line.match(/^\\s+(\\d+)\\s+(.+?)\\s+([0-9A-Z\\s\\/-]+)\\s+(\\d+)\\s+(\\d+)\\s+([0-9.-]+)\\s+(\\d+)$/);\n    if (productMatch && currentCustomer) {\n      const [, itemNumber, productName, size, cases, pieces, revenue, mfgItemNumber] = productMatch;\n      const record = {\n        customerName: currentCustomer,\n        productName: productName.trim(),\n        size: size.trim(),\n        cases: parseInt(cases) || 0,\n        pieces: parseInt(pieces) || 0,\n        revenue: parseFloat(revenue) || 0,\n        mfgItemNumber: mfgItemNumber.trim(),\n        period\n      };\n      records.push(record);\n      if (!currentProducts.includes(productName.trim())) {\n        currentProducts.push(productName.trim());\n      }\n      continue;\n    }\n\n    // Check for alternative product line format (some items might have different spacing)\n    const altProductMatch = line.match(/^\\s+(\\d+)\\s+(.+?)\\s+([A-Z0-9\\s\\/.-]+)\\s+(\\d+)\\s+(\\d+)\\s+([0-9.-]+)$/);\n    if (altProductMatch && currentCustomer && !productMatch) {\n      const [, itemNumber, productName, size, cases, pieces, revenue] = altProductMatch;\n      const record = {\n        customerName: currentCustomer,\n        productName: productName.trim(),\n        size: size.trim(),\n        cases: parseInt(cases) || 0,\n        pieces: parseInt(pieces) || 0,\n        revenue: parseFloat(revenue) || 0,\n        mfgItemNumber: itemNumber.trim(),\n        period\n      };\n      records.push(record);\n      if (!currentProducts.includes(productName.trim())) {\n        currentProducts.push(productName.trim());\n      }\n      continue;\n    }\n\n    // Check if this is a customer total line (skip it)\n    if (line.includes('CUSTOMER TOTAL :') || line.includes('RUN TOTALS :')) {\n      continue;\n    }\n  }\n\n  // Calculate metadata\n  const totalRevenue = records.reduce((sum, record) => sum + record.revenue, 0);\n  const totalCases = records.reduce((sum, record) => sum + record.cases, 0);\n  const periodRevenue = {};\n  records.forEach(record => {\n    periodRevenue[record.period] = (periodRevenue[record.period] || 0) + record.revenue;\n  });\n  return {\n    records,\n    metadata: {\n      supplier,\n      periods: [period],\n      customers: Array.from(new Set(currentCustomers)),\n      products: Array.from(new Set(currentProducts)),\n      totalRevenue,\n      totalCases,\n      periodRevenue\n    }\n  };\n}\n\n/**\n * Parse multiple Alpine reports and combine them with period progression\n */\nexport function parseMultipleAlpineReports(reports) {\n  const allRecords = [];\n  const allCustomers = new Set();\n  const allProducts = new Set();\n  const allPeriods = new Set();\n  for (const report of reports) {\n    const parsed = parseAlpineTXT(report.content, report.period);\n    allRecords.push(...parsed.records);\n    parsed.metadata.customers.forEach(c => allCustomers.add(c));\n    parsed.metadata.products.forEach(p => allProducts.add(p));\n    allPeriods.add(parsed.metadata.periods[0]);\n  }\n  const totalRevenue = allRecords.reduce((sum, record) => sum + record.revenue, 0);\n  const totalCases = allRecords.reduce((sum, record) => sum + record.cases, 0);\n  const periodRevenue = {};\n  allRecords.forEach(record => {\n    periodRevenue[record.period] = (periodRevenue[record.period] || 0) + record.revenue;\n  });\n  return {\n    records: allRecords.sort((a, b) => {\n      if (a.period !== b.period) return a.period.localeCompare(b.period);\n      if (a.customerName !== b.customerName) return a.customerName.localeCompare(b.customerName);\n      return a.productName.localeCompare(b.productName);\n    }),\n    metadata: {\n      supplier: 'ALPINE',\n      periods: Array.from(allPeriods).sort(),\n      customers: Array.from(allCustomers).sort(),\n      products: Array.from(allProducts).sort(),\n      totalRevenue,\n      totalCases,\n      periodRevenue\n    }\n  };\n}\n\n/**\n * Analyze customer progression across Alpine periods\n */\n\nexport function analyzeCustomerProgress(records, customerName) {\n  const customerRecords = records.filter(r => r.customerName === customerName);\n\n  // Group by period\n  const periodData = {};\n  customerRecords.forEach(record => {\n    if (!periodData[record.period]) {\n      periodData[record.period] = [];\n    }\n    periodData[record.period].push(record);\n  });\n  const periods = Object.entries(periodData).sort(([a], [b]) => a.localeCompare(b)).map(([period, records]) => {\n    const productRevenue = {};\n    const productCases = {};\n    records.forEach(record => {\n      productRevenue[record.productName] = (productRevenue[record.productName] || 0) + record.revenue;\n      productCases[record.productName] = (productCases[record.productName] || 0) + record.cases;\n    });\n    const topProducts = Object.entries(productRevenue).sort(([, a], [, b]) => b - a).slice(0, 5).map(([productName, revenue]) => ({\n      productName,\n      revenue,\n      cases: productCases[productName]\n    }));\n    return {\n      period,\n      totalRevenue: records.reduce((sum, r) => sum + r.revenue, 0),\n      totalCases: records.reduce((sum, r) => sum + r.cases, 0),\n      productCount: Object.keys(productRevenue).length,\n      topProducts\n    };\n  });\n\n  // Analyze trends\n  let revenueTrend = 'stable';\n  let caseTrend = 'stable';\n  let productTrend = 'stable';\n  if (periods.length === 1) {\n    revenueTrend = 'new';\n    caseTrend = 'new';\n    productTrend = 'new';\n  } else if (periods.length >= 2) {\n    const latest = periods[periods.length - 1];\n    const previous = periods[periods.length - 2];\n    const revenueChange = (latest.totalRevenue - previous.totalRevenue) / previous.totalRevenue;\n    const caseChange = (latest.totalCases - previous.totalCases) / previous.totalCases;\n    const productChange = latest.productCount - previous.productCount;\n    revenueTrend = revenueChange > 0.1 ? 'increasing' : revenueChange < -0.1 ? 'decreasing' : 'stable';\n    caseTrend = caseChange > 0.1 ? 'increasing' : caseChange < -0.1 ? 'decreasing' : 'stable';\n    productTrend = productChange > 0 ? 'expanding' : productChange < 0 ? 'contracting' : 'stable';\n  }\n  let status = 'active';\n  if (periods.length === 0) {\n    status = 'lost';\n  } else if (periods.length === 1 && revenueTrend === 'new') {\n    status = 'emerging';\n  } else if (revenueTrend === 'decreasing' || caseTrend === 'decreasing') {\n    status = 'declining';\n  } else if (revenueTrend === 'increasing' || caseTrend === 'increasing') {\n    status = 'active';\n  }\n  return {\n    customerName,\n    periods,\n    trends: {\n      revenueTrend,\n      caseTrend,\n      productTrend,\n      status\n    }\n  };\n}","map":{"version":3,"names":["parseAlpineTXT","txtContent","reportDate","lines","split","records","supplier","headerLine","find","line","includes","period","match","length","toDate","month","day","year","fullYear","padStart","currentCustomer","currentCustomers","currentProducts","i","trim","startsWith","customerMatch","customerDescription","push","productMatch","itemNumber","productName","size","cases","pieces","revenue","mfgItemNumber","record","customerName","parseInt","parseFloat","altProductMatch","totalRevenue","reduce","sum","totalCases","periodRevenue","forEach","metadata","periods","customers","Array","from","Set","products","parseMultipleAlpineReports","reports","allRecords","allCustomers","allProducts","allPeriods","report","parsed","content","c","add","p","sort","a","b","localeCompare","analyzeCustomerProgress","customerRecords","filter","r","periodData","Object","entries","map","productRevenue","productCases","topProducts","slice","productCount","keys","revenueTrend","caseTrend","productTrend","latest","previous","revenueChange","caseChange","productChange","status","trends"],"sources":["/Users/isaachirsch/Desktop/GalantCo/SalesTracker/src/utils/alpineParser.ts"],"sourcesContent":["export interface AlpineSalesRecord {\n  customerName: string;\n  productName: string;\n  size: string;\n  cases: number;\n  pieces: number;\n  revenue: number;\n  mfgItemNumber: string;\n  period: string; // e.g., \"2025-06\", \"2025-07\", \"2025-08\"\n}\n\nexport interface ParsedAlpineData {\n  records: AlpineSalesRecord[];\n  metadata: {\n    supplier: string;\n    periods: string[];\n    customers: string[];\n    products: string[];\n    totalRevenue: number;\n    totalCases: number;\n    periodRevenue: Record<string, number>;\n  };\n}\n\n/**\n * Parse Alpine TXT sales report files\n * @param txtContent Raw TXT content as string\n * @param reportDate Report date to identify the period (format: YYYY-MM)\n * @returns Parsed Alpine sales data\n */\nexport function parseAlpineTXT(txtContent: string, reportDate: string): ParsedAlpineData {\n  const lines = txtContent.split('\\n');\n  const records: AlpineSalesRecord[] = [];\n  const supplier = 'ALPINE';\n  \n  // Look for period information in the header\n  const headerLine = lines.find(line => line.includes('FROM :') && line.includes('THRU'));\n  let period = reportDate;\n  if (headerLine) {\n    const match = headerLine.match(/(\\d{1,2}\\/\\d{1,2}\\/\\d{2,4})/g);\n    if (match && match.length >= 2) {\n      const [, toDate] = match;\n      const [month, day, year] = toDate.includes('/') ? toDate.split('/') : ['', '', ''];\n      if (month && year) {\n        // Convert to YYYY-MM format\n        const fullYear = year.length === 2 ? `20${year}` : year;\n        period = `${fullYear}-${month.padStart(2, '0')}`;\n      }\n    }\n  }\n\n  // Find customers and their purchases\n  let currentCustomer = '';\n  let currentCustomers: string[] = [];\n  let currentProducts: string[] = [];\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n    \n    // Skip empty lines and headers\n    if (!line || line.startsWith('IT415V') || line.startsWith('SALES RECAP') || \n        line.startsWith('FROM :') || line.startsWith('RUN DATE') || \n        line.startsWith('GALANT GALANT') || line.startsWith('ALPINE') ||\n        line.startsWith('DESCRIPTION') || line.startsWith('-----------') ||\n        line === 'SALES' || line.includes('MFG ITEM #')) {\n      continue;\n    }\n\n    // Check if this is a customer line (starts with customer number and description)\n    const customerMatch = line.match(/^(\\d{6}-\\d{3})\\s+(.+)$/);\n    if (customerMatch) {\n      const [, , customerDescription] = customerMatch;\n      currentCustomer = customerDescription.trim();\n      currentCustomers.push(currentCustomer);\n      continue;\n    }\n\n    // Check if this is a product line (indented with spaces at the beginning)\n    const productMatch = line.match(/^\\s+(\\d+)\\s+(.+?)\\s+([0-9A-Z\\s\\/-]+)\\s+(\\d+)\\s+(\\d+)\\s+([0-9.-]+)\\s+(\\d+)$/);\n    if (productMatch && currentCustomer) {\n      const [, itemNumber, productName, size, cases, pieces, revenue, mfgItemNumber] = productMatch;\n      \n      const record: AlpineSalesRecord = {\n        customerName: currentCustomer,\n        productName: productName.trim(),\n        size: size.trim(),\n        cases: parseInt(cases) || 0,\n        pieces: parseInt(pieces) || 0,\n        revenue: parseFloat(revenue) || 0,\n        mfgItemNumber: mfgItemNumber.trim(),\n        period\n      };\n\n      records.push(record);\n      \n      if (!currentProducts.includes(productName.trim())) {\n        currentProducts.push(productName.trim());\n      }\n      continue;\n    }\n\n    // Check for alternative product line format (some items might have different spacing)\n    const altProductMatch = line.match(/^\\s+(\\d+)\\s+(.+?)\\s+([A-Z0-9\\s\\/.-]+)\\s+(\\d+)\\s+(\\d+)\\s+([0-9.-]+)$/);\n    if (altProductMatch && currentCustomer && !productMatch) {\n      const [, itemNumber, productName, size, cases, pieces, revenue] = altProductMatch;\n      \n      const record: AlpineSalesRecord = {\n        customerName: currentCustomer,\n        productName: productName.trim(),\n        size: size.trim(),\n        cases: parseInt(cases) || 0,\n        pieces: parseInt(pieces) || 0,\n        revenue: parseFloat(revenue) || 0,\n        mfgItemNumber: itemNumber.trim(),\n        period\n      };\n\n      records.push(record);\n      \n      if (!currentProducts.includes(productName.trim())) {\n        currentProducts.push(productName.trim());\n      }\n      continue;\n    }\n\n    // Check if this is a customer total line (skip it)\n    if (line.includes('CUSTOMER TOTAL :') || line.includes('RUN TOTALS :')) {\n      continue;\n    }\n  }\n\n  // Calculate metadata\n  const totalRevenue = records.reduce((sum, record) => sum + record.revenue, 0);\n  const totalCases = records.reduce((sum, record) => sum + record.cases, 0);\n  \n  const periodRevenue: Record<string, number> = {};\n  records.forEach(record => {\n    periodRevenue[record.period] = (periodRevenue[record.period] || 0) + record.revenue;\n  });\n\n  return {\n    records,\n    metadata: {\n      supplier,\n      periods: [period],\n      customers: Array.from(new Set(currentCustomers)),\n      products: Array.from(new Set(currentProducts)),\n      totalRevenue,\n      totalCases,\n      periodRevenue\n    }\n  };\n}\n\n/**\n * Parse multiple Alpine reports and combine them with period progression\n */\nexport function parseMultipleAlpineReports(\n  reports: Array<{ content: string; period: string }>\n): ParsedAlpineData {\n  const allRecords: AlpineSalesRecord[] = [];\n  const allCustomers = new Set<string>();\n  const allProducts = new Set<string>();\n  const allPeriods = new Set<string>();\n\n  for (const report of reports) {\n    const parsed = parseAlpineTXT(report.content, report.period);\n    allRecords.push(...parsed.records);\n    parsed.metadata.customers.forEach(c => allCustomers.add(c));\n    parsed.metadata.products.forEach(p => allProducts.add(p));\n    allPeriods.add(parsed.metadata.periods[0]);\n  }\n\n  const totalRevenue = allRecords.reduce((sum, record) => sum + record.revenue, 0);\n  const totalCases = allRecords.reduce((sum, record) => sum + record.cases, 0);\n\n  const periodRevenue: Record<string, number> = {};\n  allRecords.forEach(record => {\n    periodRevenue[record.period] = (periodRevenue[record.period] || 0) + record.revenue;\n  });\n\n  return {\n    records: allRecords.sort((a, b) => {\n      if (a.period !== b.period) return a.period.localeCompare(b.period);\n      if (a.customerName !== b.customerName) return a.customerName.localeCompare(b.customerName);\n      return a.productName.localeCompare(b.productName);\n    }),\n    metadata: {\n      supplier: 'ALPINE',\n      periods: Array.from(allPeriods).sort(),\n      customers: Array.from(allCustomers).sort(),\n      products: Array.from(allProducts).sort(),\n      totalRevenue,\n      totalCases,\n      periodRevenue\n    }\n  };\n}\n\n/**\n * Analyze customer progression across Alpine periods\n */\nexport interface CustomerProgressAnalysis {\n  customerName: string;\n  periods: Array<{\n    period: string;\n    totalRevenue: number;\n    totalCases: number;\n    productCount: number;\n    topProducts: Array<{ productName: string; revenue: number; cases: number }>;\n  }>;\n  trends: {\n    revenueTrend: 'increasing' | 'decreasing' | 'stable' | 'new';\n    caseTrend: 'increasing' | 'decreasing' | 'stable' | 'new';\n    productTrend: 'expanding' | 'contracting' | 'stable' | 'new';\n    status: 'active' | 'declining' | 'emerging' | 'lost';\n  };\n}\n\nexport function analyzeCustomerProgress(\n  records: AlpineSalesRecord[], \n  customerName: string\n): CustomerProgressAnalysis {\n  const customerRecords = records.filter(r => r.customerName === customerName);\n  \n  // Group by period\n  const periodData: Record<string, AlpineSalesRecord[]> = {};\n  customerRecords.forEach(record => {\n    if (!periodData[record.period]) {\n      periodData[record.period] = [];\n    }\n    periodData[record.period].push(record);\n  });\n\n  const periods = Object.entries(periodData)\n    .sort(([a], [b]) => a.localeCompare(b))\n    .map(([period, records]) => {\n      const productRevenue: Record<string, number> = {};\n      const productCases: Record<string, number> = {};\n      \n      records.forEach(record => {\n        productRevenue[record.productName] = (productRevenue[record.productName] || 0) + record.revenue;\n        productCases[record.productName] = (productCases[record.productName] || 0) + record.cases;\n      });\n\n      const topProducts = Object.entries(productRevenue)\n        .sort(([,a], [,b]) => b - a)\n        .slice(0, 5)\n        .map(([productName, revenue]) => ({\n          productName,\n          revenue,\n          cases: productCases[productName]\n        }));\n\n      return {\n        period,\n        totalRevenue: records.reduce((sum, r) => sum + r.revenue, 0),\n        totalCases: records.reduce((sum, r) => sum + r.cases, 0),\n        productCount: Object.keys(productRevenue).length,\n        topProducts\n      };\n    });\n\n  // Analyze trends\n  let revenueTrend: 'increasing' | 'decreasing' | 'stable' | 'new' = 'stable';\n  let caseTrend: 'increasing' | 'decreasing' | 'stable' | 'new' = 'stable';\n  let productTrend: 'expanding' | 'contracting' | 'stable' | 'new' = 'stable';\n\n  if (periods.length === 1) {\n    revenueTrend = 'new';\n    caseTrend = 'new';\n    productTrend = 'new';\n  } else if (periods.length >= 2) {\n    const latest = periods[periods.length - 1];\n    const previous = periods[periods.length - 2];\n    \n    const revenueChange = (latest.totalRevenue - previous.totalRevenue) / previous.totalRevenue;\n    const caseChange = (latest.totalCases - previous.totalCases) / previous.totalCases;\n    const productChange = latest.productCount - previous.productCount;\n    \n    revenueTrend = revenueChange > 0.1 ? 'increasing' : (revenueChange < -0.1 ? 'decreasing' : 'stable');\n    caseTrend = caseChange > 0.1 ? 'increasing' : (caseChange < -0.1 ? 'decreasing' : 'stable');\n    productTrend = productChange > 0 ? 'expanding' : (productChange < 0 ? 'contracting' : 'stable');\n  }\n\n  let status: 'active' | 'declining' | 'emerging' | 'lost' = 'active';\n  if (periods.length === 0) {\n    status = 'lost';\n  } else if (periods.length === 1 && revenueTrend === 'new') {\n    status = 'emerging';\n  } else if (revenueTrend === 'decreasing' || caseTrend === 'decreasing') {\n    status = 'declining';\n  } else if (revenueTrend === 'increasing' || caseTrend === 'increasing') {\n    status = 'active';\n  }\n\n  return {\n    customerName,\n    periods,\n    trends: {\n      revenueTrend,\n      caseTrend,\n      productTrend,\n      status\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}